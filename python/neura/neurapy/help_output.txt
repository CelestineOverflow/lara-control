Help on module neurapy.robot in neurapy:

NAME
    neurapy.robot

CLASSES
    builtins.object
        MultiRobot
        Robot
    
    class MultiRobot(builtins.object)
     |  Methods defined here:
     |  
     |  __init__(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Robot(builtins.object)
     |  Methods defined here:
     |  
     |  __init__(self, *args, **kwargs)
     |  
     |  activate_ethercat_interface(self)
     |      Activate the Ethercat/el6695 interface.
     |      
     |      Args: To be added in the future if required (IP setting)
     |      
     |      Returns:
     |          bool: True if the ethercat interface is activated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.activate_ethercat_interface()
     |  
     |  activate_ethernetIP_interface(self, *args)
     |      Activate the Ethernet/IP interface.
     |      
     |      Args:
     |          path (str): The path of yaml file to activate the Ethernet/IP interface.
     |      
     |      Returns:
     |          bool: True if the Ethernet/IP interface is activated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.activate_ethernetIP_interface('/path/to/yaml')
     |  
     |  activate_opcua_interface(self)
     |      Activate the OPCUA interface.
     |      
     |      Args: To be added in the future if required (IP setting)
     |      
     |      
     |      Returns:
     |          bool: True if the OPCUA interface is activated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.activate_opcua_interface()
     |  
     |  activate_profinet_interface(self)
     |      Activate the Profinet interface.
     |      
     |      Args: To be added in the future if required (IP setting)
     |      
     |      Returns:
     |          bool: True if the Profinet interface is activated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.activate_profinet_interface()
     |  
     |  activate_ros_interface(self, *args)
     |      Activate the ROS interface.
     |      
     |      Args:
     |          mode (str): The mode to activate the ROS interface.
     |              - 'position': Activate the ROS interface in position mode.
     |              - 'torque': Activate the ROS interface in torque mode.
     |      
     |      Returns:
     |          bool: True if the ROS interface is activated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.activate_ros_interface('position')
     |  
     |  activate_servo_interface(self, *args)
     |      Activate the Servo interface.
     |      
     |      Args:
     |          mode (str): The mode to activate the Servo interface.
     |              - 'position': Activate the Servo interface in position mode.
     |              - 'torque': Activate the Servo interface in torque mode.
     |      
     |      Returns:
     |          bool: True if the Servo interface is activated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.activate_servo_interface('position')
     |  
     |  compute_forward_kinematics(self, joint_angles)
     |      Compute forward kinematics(end-effector's cartesian pose) for the given joint configuration.
     |      
     |      Args:
     |          joint_angles (List): List of joint angles in radians.
     |      
     |      Returns:
     |          List: List representing the tcp pose in XYZRPY format.
     |      
     |      Raises:
     |          ValueError: If the provided joint_angles length doesn't match with robot's degrees of freedom.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              target_joint_angles = [0.2]*r.dof
     |              tcp_pose = r.compute_forward_kinematics(joint_angles)
     |  
     |  compute_inverse_kinematics(self, target_pose, reference_joint)
     |      Compute inverse kinematics(joint configuration) for the given end-effector's cartesian pose.
     |      
     |      Args:
     |          target_pose (List): List representing the target end-effector pose in XYZRPY format.
     |          reference_joint (List/numpy.array): List of reference joint angles(of robot configuration) in radians.
     |      
     |      Returns:
     |          List: List of joint angles in radians that achieve the target end-effector pose. 
     |      
     |      Raises:
     |          IKNotFound: If failed to get a solution for the given pose
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              target_end_effector_pose = [0.140448, -0.134195, 1.197456, 3.1396, -0.589, -1.025]
     |              reference_joint_angles = [-1.55, -0.69, 0.06, 1.67, -0.02, -1.57, 0.11]
     |              joint_angle_solution = r.compute_inverse_kinematics(target_end_effector_pose, reference_joint_angles)
     |  
     |  create_tool(self, tool_data)
     |      Creates a new tool in the robot's database using the provided tool data.
     |      
     |      Args:
     |          tool_data (dict): A dictionary containing the data for the new tool.
     |      
     |      Returns:
     |          bool: True if the tool was added successfully
     |      
     |      Raises:
     |          ConnectionError: If a connection to the remote database cannot be established.
     |          ValueError: If tool creation is failed with the given input data
     |      
     |      **Tool Description**
     |      
     |          .. csv-table:: 
     |              :header-rows: 1
     |              :delim: ;
     |              :widths: 15 10 50 25
     |              
     |              Key/Value;Default Value;Description;Required or Not
     |              _controlOA;False;True, if the tool is controlled by controlbox analog outputs;Not Requried
     |              _controlOD;False;True, if the tool is controlled by controlbox digital outputs;Not Required
     |              _toolOA;False;True, if the tool is controlled by analog outputs of port present on robot tool flange;Not Required
     |              _toolOD;False;True, if the tool is controlled by digital outputs of port present on robot tool flange;Not Required
     |              autoM;0;Mass of the tool;Required
     |              autoMeasureX;0;tool center of gravity (COG) in X direction,measured from robot's flange frame;Not Required
     |              autoMeasureY;0;tool center of gravity (COG) in Y direction,measured from robot's flange frame;Not Required
     |              autoMeasureZ;0;tool center of gravity (COG) in Z direction,measured from robot's flange frame;Not Required
     |              closeInput;0;percentage of gripper width for close action;Not Required
     |              cmdID;16;Input specific for certain kind of grippers;Not Required
     |              force;0;Gripper closing force; Not Required
     |              gripper;"";Gripper type;Not Required
     |              grippertype;Standard Gripper;Type of gripper Modbus/Standard;Not Required
     |              inertiaXX;0;Ixx of tool;Not Required
     |              inertiaXY;0;Ixy of tool;Not Required
     |              inertiaXZ;0;Ixz of tool;Not Required
     |              inertiaYY;0;Iyy of tool;Not Required
     |              inertiaYZ;0;Iyz of tool;Not Required
     |              inertiaZZ;0;Izz of tool;Not Required
     |              name;N/A;Name of the tool;Required
     |              offCOA;[0, 0, 0, 0, 0, 0, 0, 0];;Not Required
     |              offCOD1;0;if the tool is controlled via control box digital outputs, offCOD1 is the pin mapped to turn off (close) the tool;Not Required
     |              offCOD2;0;;Not Required
     |              offTOA;[0, 0];;Not Required
     |              offTOD;0;if the tool is controlled via tool digital outputs, offTOD is the pin mapped to turn off (close) the tool;Not Required
     |              offsetA;0;TCP roll offset;Not Required
     |              offsetB;0;TCP pitch offset;Not Required
     |              offsetC;0;TCP yaw offset;Not Required
     |              offsetX;0;TCP offset in X;Not Required
     |              offsetY;0;TCP offset in Y;Not Required
     |              offsetZ;0;TCP offset in Z;Not Required
     |              onCOA;[0, 0, 0, 0, 0, 0, 0, 0];;Not Required
     |              onCOD1;0;if the tool is controlled via control box digital outputs, onCOD1 is the pin mapped to turn on (open) the tool;Not Required
     |              onCOD2;0;;Not Required
     |              onTOA;[0, 0];;Not Required
     |              onTOD;0;if the tool is controlled via tool digital outputs, onTOD is the pin mapped to turn on (open) the tool;Not Required
     |              openInput;0;;Not Required
     |              portID;0;;Not Required
     |              protocol;0;;Not Required
     |              robot_type;Tool;;Not Required
     |              slaveID;0;;Not Required
     |              speed;0;;Not Required
     |              
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tool_data = { '_controlOA': False,
     |               '_controlOD': False,
     |               '_toolOA': False,
     |               '_toolOD': False,
     |               'autoM': 0,
     |               'autoMeasureX': 0,
     |               'autoMeasureY': 0,
     |               'autoMeasureZ': 0,
     |               'closeInput': 0,
     |               'cmdID': 16,
     |               'description': 'Tool Description',
     |               'force': 0,
     |               'gripper': '',
     |               'grippertype': 'Standard Gripper',
     |               'inertiaXX': 0,
     |               'inertiaXY': 0,
     |               'inertiaXZ': 0,
     |               'inertiaYY': 0,
     |               'inertiaYZ': 0,
     |               'inertiaZZ': 0,
     |               'name': 'somerandomtool',
     |               'offCOA': [0, 0, 0, 0, 0, 0, 0, 0],
     |               'offCOD1': 0,
     |               'offCOD2': 0,
     |               'offTOA': [0, 0],
     |               'offTOD': 0,
     |               'offsetA': 0,
     |               'offsetB': 0,
     |               'offsetC': 0,
     |               'offsetX': 0,
     |               'offsetY': 0,
     |               'offsetZ': 0,
     |               'onCOA': [0, 0, 0, 0, 0, 0, 0, 0],
     |               'onCOD1': 0,
     |               'onCOD2': 0,
     |               'onTOA': [0, 0],
     |               'onTOD': 0,
     |               'openInput': 0,
     |               'portID': '',
     |               'protocol': 0,
     |               'robot_type': 'Tool',
     |               'slaveID': 0,
     |               'speed': 0}
     |      
     |              tools_data = r.create_tool(tool_data)
     |  
     |  deactivate_ethercat_interface(self)
     |      Deactivate the Ethercat interface.
     |      
     |      Returns:
     |          bool: True if the Ethercat interface is deactivated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.deactivate_opcua_interface()
     |  
     |  deactivate_ethernetIP_interface(self)
     |      Deactivate the Ethernet/IP interface.
     |      
     |      Returns:
     |          bool: True if the Ethernet/IP interface is deactivated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.deactivate_ethernetIP_interface()
     |  
     |  deactivate_opcua_interface(self)
     |      Deactivate the OPCUA interface.
     |      
     |      Returns:
     |          bool: True if the OPCUA interface is deactivated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.deactivate_ethernetIP_interface()
     |  
     |  deactivate_profinet_interface(self)
     |      Deactivate the Profinet interface.
     |      
     |      Returns:
     |          bool: True if the Profinet interface is deactivated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.deactivate_profinet_interface()
     |  
     |  deactivate_ros_interface(self)
     |      Deactivate the ROS interface.
     |      
     |      Returns:
     |          bool: True if the ROS interface is deactivated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.deactivate_ros_interface()
     |  
     |  deactivate_servo_interface(self)
     |      Deactivate the Servo interface.
     |      
     |      Returns:
     |          bool: True if the Servo interface is deactivated successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.deactivate_servo_interface()
     |  
     |  disable_collision_detection(self)
     |      Disable collision detection on the robot.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.disable_collision_detection()
     |  
     |  disable_reflex(self)
     |      Disable reflex after collision.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.disable_reflex()
     |  
     |  enable_collision_detection(self)
     |      Enable collision detection on the robot.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.enable_collision_detection()
     |  
     |  enable_reflex(self)
     |      Enable reflex after collision.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.enable_reflex()
     |  
     |  encoder2rad(self, impulses)
     |      Convert encoder impulses to joint angles in radians.
     |      
     |      Args:
     |          impulses (list): A list of encoder impulses for each joint.
     |      
     |      Returns:
     |          list: A list of joint angles in radians corresponding to the provided encoder impulses.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          
     |                  import time
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  encoder_ticks = r.robot_status('loadSideEncValue')
     |                  joint_angles = r.encoder2rad(encoder_ticks)
     |  
     |  execute_program(self, name)
     |      To run a program created from teach pendant's tree program creator
     |      
     |      :param name: The name of the saved program to execute.
     |      :type name: str
     |      :return: True if the program executed successfully, raises an exception if execution encountered an error.
     |      :rtype: bool
     |      :raises Exception: If an exception is raised during program execution, this function raises it with the exception message.
     |      
     |      Sample Usage:
     |      
     |      .. code-block:: python
     |      
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          try:
     |              result = r.execute_program("Program_001")
     |              if result:
     |                  print("Program executed successfully.")
     |          except Exception as e:
     |              print("Error: " + str(e))
     |  
     |  executor(self, list_of_planned_motion_ids)
     |      Execute already planned motion IDs.
     |      
     |      This method allows you to execute a list of planned motion IDs, which represent pre-defined motion sequences or plans. This needs to be used in conjuction with plan_move_ciruclar/joint/linear/composite/record_path functions.
     |      
     |      Args:
     |          List of Int: List of planned motion IDs to be executed.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              planned_motion_ids = r.plan_move_joint([0]*r.dof)  # Replace with your planned motion IDs
     |              r.executor([planned_motion_ids])
     |  
     |  finish(self)
     |  
     |  get_analog_input(self, io_name)
     |      Get the value of an analog input.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): The name of the analog input.
     |      
     |      Returns:
     |          The value of the analog input.
     |          
     |                              
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_analog_input(1)
     |              print(io_get)
     |  
     |  get_analog_output(self, io_name)
     |      Get the value of an analog output.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): The name of the analog output.
     |      
     |      Returns:
     |          float: The value of the analog output.
     |      
     |                              
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_analog_output(1)
     |              print(io_get)
     |  
     |  get_current_cartesian_pose(self)
     |      Get the current Cartesian pose of the robot's TCP.
     |      
     |      Returns:
     |          List: Cartesian pose of the tcp in the form of [X,Y,Z,w,x,y,z]
     |      
     |          X,Y,Z - position in meters
     |          w,x,y,z - rotation representation in quaternion
     |      
     |      **Sample Usage:**
     |      
     |      .. code-block:: python
     |      
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          cartesian_pose = r.get_current_cartesian_pose()
     |      
     |      .. deprecated:: 4.13
     |         This function is deprecated and will be removed in future
     |         versions. Use `get_tcp_pose_quaternion` instead.
     |  
     |  get_current_cartesian_pose_with_timestamp(self)
     |      Get the current Cartesian pose of the robot's TCP along with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of a list of robot Cartesian position values and UTC timestamp
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              cartesian_pose, timestamp = r.get_current_cartesian_pose_with_timestamp()
     |      
     |      .. deprecated:: 4.13
     |         This function is deprecated and will be removed in future
     |         versions. Use `get_tcp_pose_quaternion_with_timestamp` instead.
     |  
     |  get_current_joint_angles(self)
     |      Get current joint angles of the robot.
     |      
     |      Returns:
     |          List: List of robot joint angles in radians
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              joint_angles = r.get_current_joint_angles()
     |  
     |  get_current_joint_angles_with_timestamp(self)
     |      Get the current joint angles of the robot along with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of a list of robot joint angles in radians and UTC timestamp
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              joint_angles, timestamp = r.get_current_joint_angles_with_timestamp()
     |  
     |  get_current_joint_torques(self)
     |      Get the current joint torques of the robot.
     |      
     |      Returns:
     |          List: List of joint torque values
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              joint_torques = r.get_current_joint_torques()
     |  
     |  get_current_joint_torques_with_timestamp(self)
     |      Get the current joint torques of the robot along with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of a list of joint torque values and UTC timestamp
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              joint_torques, timestamp = r.get_current_joint_torques_with_timestamp()
     |  
     |  get_current_joint_velocities(self)
     |      Get current joint velocites of the robot.
     |      
     |      Returns:
     |          List: List of robot joint velocites in radians/sec
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              joint_velocites = r.get_current_joint_velocities()
     |  
     |  get_current_joint_velocities_with_timestamp(self)
     |      Get the current joint velocities of the robot along with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of a list of robot joint velocities in radians/sec and UTC timestamp
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              joint_velocities, timestamp = r.get_current_joint_velocities_with_timestamp()
     |  
     |  get_current_load_side_encoder_values(self)
     |      Get the current load side encoder ticks of the robot.
     |      
     |      Returns:
     |          List: List of encoder tick values
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              encoder_ticks = r.get_current_load_side_encoder_values()
     |  
     |  get_current_load_side_encoder_values_with_timestamp(self)
     |      Get the current load side encoder ticks of the robot along with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of a list of encoder tick values and UTC timestamp
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              encoder_ticks, timestamp = r.get_current_load_side_encoder_values_with_timestamp()
     |  
     |  get_current_motor_side_encoder_values(self)
     |      Get the current motor side encoder ticks of the robot .
     |      
     |      Returns:
     |          List: List of encoder tick values
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              encoder_ticks = r.get_current_motor_side_encoder_values()
     |  
     |  get_current_motor_side_encoder_values_with_timestamp(self)
     |      Get the current motor side encoder ticks of the robot along with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of a list of encoder tick values and UTC timestamp
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              encoder_ticks, timestamp = r.get_current_motor_side_encoder_values_with_timestamp()
     |  
     |  get_current_tool_cogs(self)
     |      Get the current tool center of gravity (COG) in XYZ directions(measured from robot's flange frame/tool mounting point).
     |      
     |      Returns:
     |          List: List representing the tool COG in XYZ directions.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tool_cog = r.get_current_tool_cogs()
     |  
     |  get_current_tool_inertias(self)
     |      Get the current tool inertias Ixx, Iyy, Izz, Ixy, Ixz, and Iyz.
     |      
     |      Returns:
     |          List: List representing the tool inertias with these values.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tool_inertias = r.get_current_tool_inertias()
     |  
     |  get_current_tool_mass(self)
     |      Get the current tool mass.
     |      
     |      Returns:
     |          float: The mass of the tool.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tool_mass = r.get_current_tool_mass()
     |  
     |  get_current_tool_properties(self)
     |      Get the current tool properties.
     |      
     |      Returns:
     |          List: List containing the tool properties. i.e . [tool_mass,roll_offset,pitch_offset,yaw_offset,x_offset,y_offset,z_offset,COG_x,COG_y,COG_z,Ixx,Iyy, Izz, Ixy, Ixz, and Iyz]
     |          
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tool_properties = r.get_current_tool_properties()
     |  
     |  get_current_tool_rpy_offsets(self)
     |      Get the current tool roll, pitch, and yaw (RPY) offsets in radians.
     |      
     |      Returns:
     |          List: List representing the tool RPY offsets in radians.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tool_rpy_offsets = r.get_current_tool_rpy_offsets()
     |  
     |  get_current_tool_translation_offsets(self)
     |      Get the current tool translation offsets in XYZ directions.
     |      
     |      Returns:
     |          List: List representing the tool translation offsets in XYZ directions..
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tool_offsets = r.get_current_tool_translation_offsets()
     |  
     |  get_diagnostics(self)
     |      Method to query current robot diagnostics
     |      
     |      Args : N/A
     |      
     |      Return Values:
     |      
     |      dictionary : If critical dictionary contains diagnostics values i.e. critical, powered_off, collision_status else returns empty dictionary
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |              
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              print(r.get_diagnostics())
     |  
     |  get_digital_input(self, io_name)
     |      Get the value of a digital input.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): The name of the digital input.
     |      
     |      Returns:
     |          The value of the digital input.
     |          
     |                      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_digital_input(1)
     |              print(io_get)
     |  
     |  get_digital_output(self, io_name)
     |      Get the value of a digital output.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): The name of the digital output.
     |      
     |      Returns:
     |          The value of the digital output 0 or 1.
     |          
     |                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_digital_output(1)
     |              print(io_get)
     |  
     |  get_doc(self, function_name)
     |      Get the description and sample usage of the specified function.
     |      
     |      Args:
     |          function_name (str) : The name of the function for which description is needed.
     |      
     |      Returns:
     |          description(str): short description and usage of the function.
     |          
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              description = r.get_doc("move_joint")
     |              print(description)
     |  
     |  get_encoder_offsets(self)
     |      To retrieve the encoder offsets of a robot.
     |      
     |      Returns:
     |          List[float]: A list containing the encoder offsets for the robot's encoders.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              encoder_offsets = r.get_encoder_offsets()
     |  
     |  get_errors(self, *args, **kwargs)
     |      Query the list of errors present on the robot.
     |      
     |      Returns:
     |          List[str]: A list of errors present on the robot.
     |              
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |      
     |                  r = Robot()
     |                  print(r.get_errors())
     |  
     |  get_ext_digital_input(self, io_name)
     |      Get the value of an external digital input. Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): Pin number of the external digital input.
     |      
     |      Returns:
     |          The value of the digital input.
     |          
     |                      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_digital_input(1)
     |              print(io_get)
     |  
     |  get_ext_digital_output(self, io_name)
     |      Get the value of an external digital output. Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): Pin number of the digital output.
     |      
     |      Returns:
     |          The value of the digital output 0 or 1.
     |          
     |                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_ext_digital_output(1)
     |              print(io_get)
     |  
     |  get_flange_pose(self, timestamp=False, representation='rpy')
     |      Get the current flange pose in XYZRPY format.
     |      
     |      Returns:
     |          List: List representing the flange pose with XYZRPY values.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              flange_pose = r.get_flange_pose()
     |  
     |  get_flange_pose_quaternion(self)
     |      Get the current flange pose in XYZwxyz format.
     |      
     |      Returns:
     |          List: List representing the flange pose with [X,Y,Z,w,x,y,z]
     |          
     |          X,Y,Z - position in meters
     |          w,x,y,z - rotation representation in quaternion
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              flange_pose_quaternion = r.get_flange_pose_quaternion()
     |  
     |  get_flange_pose_quaternion_with_timestamp(self)
     |      Get the current flange pose in XYZwxyz format with UTC timestamp.
     |      
     |      Returns:
     |          List: List representing the flange pose with [X,Y,Z,w,x,y,z] and UTC timestamp
     |          
     |          X,Y,Z - position in meters
     |          w,x,y,z - rotation representation in quaternion
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              flange_pose_quaternion, timestamp = r.get_flange_pose_quaternion_with_timestamp()
     |  
     |  get_flange_pose_with_timestamp(self)
     |      Get the current tool flange pose in XYZRPY format with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of the flange pose with XYZRPY values and UTC timestamp
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              flange_pose, timestamp = get_flange_pose_with_timestamp
     |  
     |  get_gravity_vector(self)
     |      To retrieve the set gravity vector value from the database.
     |      
     |      Returns:
     |          dict : A dict containing the gravity vector values
     |      
     |      Raises:
     |          ConnectionError: If there is a failure to connect to the robot's database.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              vector = r.get_gravity_vector()
     |              print(vector)
     |  
     |  get_io_configuration(self)
     |      Get the number of available IOs.
     |      
     |      Returns:
     |          dict: A dictionary containing the type and number of the IOs.
     |      
     |                                      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_configuration = r.get_io_configuration()
     |              print(io_configuration)
     |  
     |  get_joint_acceleration(self)
     |      Get the current acceleration value for joint motion.
     |      
     |      Returns:
     |      float: The current acceleration value for joint motion.(Percentage of maximum angular acceleration)
     |  
     |  get_joint_speed(self)
     |      Get the current speed value for joint motion.
     |      
     |      Returns:
     |      float: The current speed value for joint motion.(Percentage of maximum angular speed)
     |  
     |  get_linear_acceleration(self)
     |      Get the current acceleration value for linear motion.
     |      
     |      Returns:
     |      float: The current acceleration value for linear motion.(m/s2)
     |  
     |  get_linear_speed(self)
     |      Get the current speed value for linear motion.
     |      
     |      Returns:
     |      float: The current speed value for linear motion.(m/s)
     |  
     |  get_mode(self, *args, **kwargs)
     |      .. warning::
     |      
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`is_robot_in_teach_mode`
     |          - :func:`is_robot_in_automatic_mode`
     |          - :func:`is_robot_in_semi_automatic_mode`
     |          
     |      Query the current robot mode (Teach/Automatic/SemiAutomatic).
     |      
     |      Returns:
     |          str: The current robot mode.
     |              - 'Teach' if the robot is in Teach mode.
     |              - 'Automatic' if the robot is in Automatic mode.
     |              - 'SemiAutomatic' if the robot is in semi-automatic mode.
     |              
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  mode = r.get_mode()
     |                  print(mode)
     |  
     |  get_override(self)
     |      Get the current override value.
     |      
     |      Returns:
     |          float: The current override value.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              override_value = r.get_override()
     |              print(f"Current override value: {override_value}")
     |  
     |  get_point(self, name, representation='Joint')
     |      Retrieves a point from the database based on the given name.
     |      
     |      Args:
     |          name (str): The name of the point to retrieve from the database.
     |          representation (str): To specify the point representation type.
     |          
     |                  Joint - Default - returns Joint values of the stored point
     |                  
     |                  Cartesian - returns Cartesian pose of the stored point
     |      
     |      Returns:
     |          List: A list containing the details of the point.
     |          
     |              for Joint representation - List contains the values of joint angles in radian
     |              
     |              for Cartesian representation - List contains X,Y,Z,R,P,Y values
     |                  
     |                  X,Y,Z - 3D position  - in meters
     |      
     |                  R,P,Y - 3D rotation represented in Euler angles in radians - rotation order 'ZYX'
     |      
     |      Raises:
     |          ConnectionError: If a connection to the remote database cannot be established.
     |          ValueError: If no point is saved in the database with the given name or the given representation type is invalid
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  point = r.get_point("P1",representation="Joint")
     |                  print(point)
     |                  point = r.get_point("P1",representation="Cartesian")
     |                  print(point)
     |  
     |  get_program_names(self)
     |      Retrieves list of program names from the robot's database
     |      
     |      Returns:
     |          list: A list of names of the programs available in the robot's database.
     |      
     |      Raises:
     |          ConnectionError: If connection to the remote database cannot be established.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          program_names = r.get_program_names()
     |          print(program_names)
     |  
     |  get_reference_frame(self, name)
     |      Retrieve the coordinates and orientations of a user-defined reference frame.
     |      
     |      Args:
     |          name (str): The name of the reference frame to retrieve.
     |          
     |      Returns:
     |          List : A list containing the values of the reference frame.
     |              
     |              frame - [X,Y,Z,R,P,Y]
     |      
     |              X,Y,Z - 3D position  - in meters
     |      
     |              R,P,Y - 3D rotation represented in Euler angles in radians - rotation order 'ZYX'
     |      
     |      Raises:
     |          ConnectionError: If there is a failure to connect to the robot's database.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              frame = r.get_reference_frame("tool_frame")
     |              print(frame)
     |  
     |  get_reference_frame_with_offset(self, name, offset)
     |      Retrieve a reference frame with an applied offset to its position.
     |      
     |      Args:
     |          name (str or list): The name of the reference frame or the reference frame as a list.
     |          offset (list): A list containing the offset values [X, Y, Z] to apply to the frame's position.
     |      
     |      Returns:
     |          list: A list containing the [X, Y, Z, A, B, C] values (coordinates and angles)
     |              of the translated reference frame.
     |      
     |      Raises:
     |          ValueError: If the name argument is neither a valid string nor a list.
     |                      If the offset argument is not a list of length 3.
     |      Sample Usage
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              x_offset = 0.02 # in meters
     |              y_offset = 0.1 # in meters
     |              z_offset = 0.0 # in meters
     |              frame = r.get_reference_frame_with_offset("world",[x_offset,y_offset,z_offset])
     |              print(frame)
     |  
     |  get_register_bytes(self, tag_name, first_element, last_element, T2O=False)
     |      Returns a python "bytes" object from a T2O or O2T register specified by its tag name and index range
     |      from first to last element.
     |      
     |           Args:
     |               tag_name (str): the register's tag name (without any element index) as found in the
     |                               official EDS files or in the detailed mapping in EtherNET/IP users documentation
     |      
     |               first_element (int): index of first requested register element.
     |      
     |               last_element (int): index of last requested register element.
     |      
     |               T2O (bool): use True if register is in Target-to-Originator registry instead of Originator-to-Target
     |      
     |           Returns:
     |               bytes: encoded values or None on failure (invalid range, communication failure)
     |      
     |           **Sample Usage:**
     |      
     |               .. code-block:: python
     |      
     |                   from neurapy.robot import Robot
     |                   r = Robot()
     |                   octet_list = r.get_register_bytes("INTIN", 1, 4) # return second to fifth integer elements from
     |                                                       # input (O2T) integer register
     |  
     |  get_register_values(self, tag_name, first_element, last_element, T2O=False)
     |      Returns values from a T2O or O2T register specified by its tag name and index range from first to last element
     |      
     |           Args:
     |               tag_name (str): the register's tag name (without any element index) as found in the
     |                                   official EDS files or in the detailed mapping in EtherNET/IP users documentation
     |      
     |               first_element (int): index of first requested register element.
     |      
     |               last_element (int): index of last requested register element.
     |      
     |               T2O (bool): use True if register is in Target-to-Originator registry instead of Originator-to-Target
     |      
     |           Returns:
     |               [int/float]: list of python values or empty list on failure (invalid range, communication failure)
     |      
     |           **Sample Usage:**
     |      
     |               .. code-block:: python
     |      
     |                   from neurapy.robot import Robot
     |                   r = Robot()
     |                   octet_list = r.get_register_values("INTIN", 1, 4) # return second to fifth integer elements from
     |                                                       # input (O2T) integer register
     |  
     |  get_selected_tool_data(self)
     |      Retrieves the selected tool from the robot's database.
     |      
     |      Returns:
     |          list: The selected tool data from database in the robot's database.
     |      
     |      Raises:
     |          ConnectionError: If connection to the remote database cannot be established.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  tool = r.get_selected_tool_data()
     |                  print(tool)
     |  
     |  get_servo_trajectory_scaling_factor(self, *args, **kwargs)
     |      Method to get the trajectory scaling factor from ServoJ
     |      
     |      Returns:
     |      - [double] scaling factor
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              import time
     |              from ruckig import InputParameter, OutputParameter, Result, Ruckig
     |      
     |              r = Robot()
     |      
     |              #Switch to external servo mode
     |              r.activate_servo_interface('position')
     |      
     |              dof = 6
     |      
     |              otg = Ruckig(dof, 0.001)  # DoFs, control cycle
     |              inp = InputParameter(dof)
     |              out = OutputParameter(dof)
     |      
     |              inp.current_position = r.get_current_joint_angles()
     |              inp.current_velocity = [0.]*dof
     |              inp.current_acceleration = [0.]*dof
     |      
     |              inp.target_position = [0., 0., 0., 0., 0., 0.]
     |              inp.target_velocity = [0.]*dof
     |              inp.target_acceleration = [0.]*dof
     |      
     |              inp.max_velocity = [0.5]*dof
     |              inp.max_acceleration = [3]*dof
     |              inp.max_jerk = [10.]*dof
     |              res = Result.Working
     |      
     |      
     |      
     |              while res == Result.Working:
     |                  '''
     |                  Error code is returned through Servo. 
     |                  '''
     |                  error_code = 0
     |                  if(error_code < 3):
     |      
     |                      res = otg.update(inp, out)
     |      
     |                      position = out.new_position
     |                      velocity = out.new_velocity 
     |                      acceleration = out.new_acceleration
     |      
     |                      error_code = r.servo_j(position, velocity, acceleration)
     |                      scaling_factor = r.get_servo_trajectory_scaling_factor()
     |                      out.pass_to_input(inp)
     |                      time.sleep(0.001)
     |                  else:
     |                      print("Servo in error, error code, ", error_code)
     |                      break
     |              r.deactivate_servo_interface()
     |      
     |              r.stop()
     |  
     |  get_sim_or_real(self, *args, **kwargs)
     |      .. warning::
     |      
     |          This function is deprecated and will be removed in the next version. Please use the following function instead:
     |      
     |          - :func:`is_robot_in_simulation`
     |          
     |      Method to get the mode of the robot sim/real
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  context = r.get_sim_or_real()
     |                  print(context) #Real/Simulation
     |  
     |  get_tcp_pose(self, timestamp=False, representation='rpy')
     |      to get the current tcp pose in XYZRPY format
     |      
     |      Returns:
     |          List: TCP pose as [X,Y,Z,R,P,Y]
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  tcp_pose = r.get_tcp_pose()
     |                  print(tcp_pose)
     |  
     |  get_tcp_pose_quaternion(self)
     |      to get the current tcp pose in XYZwxyz format
     |      
     |      Returns:
     |          List: TCP pose as [X,Y,Z,w,x,y,z]
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  tcp_pose_quaternion = r.get_tcp_pose_quaternion()
     |  
     |  get_tcp_pose_quaternion_with_timestamp(self)
     |      to get the current tcp pose in XYZwxyz format along with UTC timestamp
     |      
     |      Returns:
     |          Tuple: TCP pose as [X,Y,Z,w,x,y,z] and UTC timestamp
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  tcp_pose_quaternion = r.get_tcp_pose_quaternion()
     |  
     |  get_tcp_pose_with_timestamp(self)
     |      Get the current robot's TCP pose in XYZRPY format along with UTC timestamp.
     |      
     |      Returns:
     |          Tuple: Tuple of the robot's TCP pose and UTC timestamp.
     |      
     |      **Sample Usage:**
     |      
     |      .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              tcp_pose, timestamp = r.get_tcp_pose_with_timestamp()
     |  
     |  get_tool_analog_input(self, io_name)
     |      Get the value of a tool analog input.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (str): The name of the tool analog input.
     |      
     |      Returns:
     |          The value of the tool analog input.
     |      
     |                                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_tool_analog_input(1)
     |              print(io_get)
     |  
     |  get_tool_digital_input(self, io_name)
     |      Get the value of a tool digital input.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (str): The name of the tool digital input.
     |      
     |      Returns:
     |          The value of the tool digital input.
     |          
     |                                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_tool_digital_input(1)
     |              print(io_get)
     |  
     |  get_tool_digital_output(self, io_name)
     |      Get the value of a tool digital output.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (str): The name of the tool digital output.
     |      
     |      Returns:
     |          The value of the tool digital output.
     |          
     |                                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.get_tool_digital_output(1)
     |              print(io_get)
     |  
     |  get_tool_flange_pose(self)
     |      Get the current flange pose in XYZRPY format.
     |      
     |      Returns:
     |          List: List representing the flange pose with XYZRPY values.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              flange_pose = r.get_tool_flange_pose()
     |      
     |      .. deprecated:: 4.13
     |         This function is deprecated and will be removed in future
     |         versions. Use `get_flange_pose` instead.
     |  
     |  get_tools(self)
     |      Retrieves list of tools from the robot's database.
     |      
     |      Returns:
     |          list: A list of tools available in the robot's database.
     |      
     |      Raises:
     |          ConnectionError: If connection to the remote database cannot be established.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  tools = r.get_tools()
     |                  print(tools)
     |  
     |  get_warnings(self, *args, **kwargs)
     |      Query the list of warnings present on the robot.
     |      
     |      Returns:
     |          List[str]: A list of warnings present on the robot.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |              
     |                  r = Robot()
     |                  print(r.get_warnings())
     |  
     |  get_zerog_status(self)
     |      .. warning::
     |          This function is deprecated and will be removed in the next version. Please use the following function instead:
     |      
     |          - :func:`is_free_drive_mode_enabled`
     |      
     |          
     |      Get the status of the robot free drive mode.
     |      
     |      Returns:
     |          str: The status of the free drive mode.
     |              - 'Turned On' if the free drive mode is turned on.
     |              - 'Turned Off' if the free drive mode is turned off.
     |              
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  import time
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  status = r.get_zerog_status()
     |  
     |  grasp(self)
     |      To grasp the object with the attached gripper
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.grasp()
     |  
     |  gripper(self, *args, **kwargs)
     |      Method to control the gripper attached to the robot
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from time import sleep
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.gripper('on')
     |              sleep(2)
     |              r.gripper('off')
     |  
     |  ik_fk(self, *args, **kwargs)
     |      .. warning::
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`compute_forward_kinematics`
     |          - :func:`compute_inverse_kinematics`
     |      
     |      Compute forward/inverse kinematics for a given configuration.
     |      
     |      Args:
     |          operation_type (str): The type of operation.
     |              - 'ik': Joint configuration calculation for the given cartesian position.
     |              - 'fk': Cartesian position calculation for the given joint configuration.
     |      
     |          target_pose (List[float], optional): The target pose in XYZRPY format. Required only for 'ik' calculation.
     |      
     |          target_angle (List[float], optional): The list of joint angles. Required only for 'fk' calculation.
     |      
     |          current_joint (List[float], optional): The list of current joint angles. Required only for 'fk' calculation.
     |      
     |      Returns:
     |          Union[List[float], List[float]]: The target position in XYZRPY format if operation_type is 'ik'.
     |              The target angle if operation_type is 'fk'.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              target_pose = r.ik_fk("fk", target_angle = [0.2,0.2,0.2,0.2,0.2,0.2])
     |              target_angle = r.ik_fk("ik", target_pose = [0.140448, -0.134195, 1.197456, 3.1396, -0.589, -1.025],current_joint = [-1.55, -0.69, 0.06, 1.67, -0.02, -1.57, 0.11])
     |  
     |  initialize_servo(self)
     |  
     |  io(self, *args, **kwargs)
     |      Access and manipulate (output) IO values on the robot.
     |      
     |      Args:
     |          operation_type (str): The type of operation.
     |              - 'get': Get the IO value.
     |              - 'set': Set the output IO value.
     |      
     |          io_name (str): The name of the IO. (List of available IO names can be found here)
     |      
     |          target_value (Any, optional): The target value of the IO. Required only for the 'set' operation.
     |      
     |      Returns:
     |          Union[Any, bool]: The value of the queried 'io_name' for the 'get' operation.
     |              True or False if the 'set' operation has succeeded or not.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_get = r.io("get", io_name = "DO_1")
     |              io_set = r.io("set", io_name = "DO_2", target_value = True)
     |              print(io_get,io_set)
     |  
     |  is_collision_enabled(self)
     |      Check if reflex after collision is enabled for the robot.
     |      
     |      Returns:
     |          bool: True if reflex collision avoidance is enabled, False otherwise.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.is_collision_enabled():
     |                  print("Collision detection is enabled.")
     |              else:
     |                  print("Collision detction is not enabled.")
     |  
     |  is_free_drive_mode_enabled(self)
     |      Get the status of the robot free drive mode.
     |      
     |      Returns:
     |          bool: The status of the free drive mode.
     |              - True if the free drive mode is turned on.
     |              - False if the free drive mode is turned off.
     |              
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  import time
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  status = r.is_free_drive_mode_enabled()
     |  
     |  is_reflex_enabled(self)
     |      Check if reflex after collision is enabled for the robot.
     |      
     |      Returns:
     |          bool: True if reflex collision avoidance is enabled, False otherwise.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.is_reflex_enabled():
     |                  print("Reflex collision avoidance is enabled.")
     |              else:
     |                  print("Reflex collision avoidance is not enabled.")
     |  
     |  is_robot_in_automatic_mode(self)
     |      Method to check whether the robot is in automatic mode or not
     |      
     |      Returns:
     |          bool: True, if the robot is in automatic mode, False if it is not in automatic mode
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  if r.is_robot_in_automatic_mode():
     |                      print("Robot is in automatic mode")
     |                  else:
     |                      print("Robot is not in automatic mode")
     |  
     |  is_robot_in_collision(self)
     |      Check if the robot is currently in collision.
     |      
     |      Returns:
     |          bool: True if the robot is in collision, False otherwise.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.is_robot_in_collision():
     |                  print("Robot is in collision.")
     |              else:
     |                  print("Robot is not in collision.")
     |  
     |  is_robot_in_semi_automatic_mode(self)
     |      Method to check whether the robot is in semi automatic mode or not
     |      
     |      Returns:
     |          bool: True, if the robot is in semi automatic mode, False if it is not in semi automatic mode
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  if r.is_robot_in_semi_automatic_mode():
     |                      print("Robot is in semi automatic mode")
     |                  else:
     |                      print("Robot is not in semi automatic mode")
     |  
     |  is_robot_in_simulation(self)
     |      Method to check whether the robot is in simulation or not
     |      
     |      Returns:
     |          bool: True, if the robot is in simulation, False if it is in real mode
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  if r.is_robot_in_simulation():
     |                      print("Robot is in simulation")
     |                  else:
     |                      print("Robot is in real")
     |  
     |  is_robot_in_teach_mode(self)
     |      Method to check whether the robot is in teach mode or not
     |      
     |      Returns:
     |          bool: True, if the robot is in teach mode, False if it is not in teach mode
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  if r.is_robot_in_teach_mode():
     |                      print("Robot is in teach mode")
     |                  else:
     |                      print("Robot is not in teach mode")
     |  
     |  jog(self, *args, **kwargs)
     |      Method to jog programatically. This needs to used in conjuction with turn_on_jog, turn_off_jog methods.
     |      
     |      Args:
     |      - set_jogging_external_flag (int): A flag to enable external jogging mode
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              
     |              '''
     |              jog_velocity - velocity ranging from [-1,1] for all joints. Signifies percentage of total speed used (1 = 100%)
     |              jog_type - can be either cartesian or joint jogging
     |              turn_on_jog sets the parameters of external jogging, jogging velocity, jogging type and sets the mode for jogging to external mode.
     |              '''
     |              r.turn_on_jog(jog_velocity=[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], jog_type='Joint')
     |              r.jog(set_jogging_external_flag=1)
     |              i = 0
     |              '''
     |              Requires minimum number of cycles in the loop for performing jogging. 
     |              Depends upon jogging velocity, override.
     |              '''
     |              while i < 500:
     |                  #command to set flag to start jogging in external mode. This command has to be used each time external jog command has to be sent
     |                  r.jog(set_jogging_external_flag=1)
     |                  i += 1
     |                  
     |              #Command to switch back to internal jogging mode (GUI)
     |              r.turn_off_jog()
     |  
     |  list_methods(self)
     |      To list the available functions in the API
     |      
     |      Returns:
     |          table(str): Table listing the available functions and short description of the functions.
     |          
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.list_methods()
     |  
     |  motion_status(self)
     |      Query the motion status of the robot.
     |      
     |      Returns:
     |          str: The motion status of the robot.
     |              - 'NOT_RUNNING': If the robot is not running.
     |              - 'RUNNING'    : If the robot is running.
     |              - 'PAUSED'     : If the robot is in a paused state.
     |              
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |      
     |                  r = Robot()
     |                  print(r.motion_status())
     |  
     |  move_circular(self, *args, **kwargs)
     |      To move the robot in a circular path across the given poses. This method takes the following arguments/keyword arguments:
     |      
     |      :param target_pose: List of 3 pose configurations (starting, middle, and end points). (type: Pose configuration - [X,Y,Z,R,P,Y], float, units: Position values in meters and rotation values in radians, required: Yes) Alternative: List of Strings (Type: [String], names of existing points)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: DYNAMIC_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param weaving: Toogle if Weaving should be used for the Motion(type: Bool, units: N/A, default_value: False, required: No)
     |          
     |          True - Weaving is turned on, motion inside are exeuted with given weaving parameters
     |          False - Weaving is turned off, motion does not include Weaving
     |      
     |      :para pattern: The Pattern which should be used for the Weaving (type: Int, units: N/A, default_value: 2, required: No)
     |      
     |          1 - SINE, if selected uses a Sine wave, ignores dwell times
     |          2 - TRAPEZOIDAL, if selected uses a trapezoidal wave, implements dwell times
     |          3 - CIRCLE (experimental), if selected uses a circle wave, ignores dwell time and amplitude offset
     |      
     |      :param amplitude_left: The amplitude on the left side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param amplitude_right: The amplitude on the right side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param frequency: the frequency for the wave form (type: Float, units: Hz, default_value: 10.0, required: No)
     |      
     |      :param dwell_time_left: the wait time, for trapezoidal waves at each peak (left defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param dwell_time_right: the wait time, for trapezoidal waves at each peak (right defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param elevation: the rotation around the velocity vector (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param azimuth: the rotation around the z-Axis of the tool (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      Return Values:
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              circular_property = {
     |                  "speed": 0.25,
     |                  "acceleration": 0.1,
     |                  "jerk": 100,
     |                  "rotation_speed": 1.57,
     |                  "rotation_acceleration": 5.0,
     |                  "rotation_jerk": 100,
     |                  "blending_mode": 1,
     |                  "target_pose": [
     |                      [
     |                          0.3744609827431085,
     |                          -0.3391784988266481,
     |                          0.23276604279256016,
     |                          3.14119553565979,
     |                          -0.00017731254047248513,
     |                          -0.48800110816955566
     |                      ],
     |                      [
     |                          0.37116786741831503,
     |                          -0.19686307684994242,
     |                          0.23300456855796453,
     |                          3.141423225402832,
     |                          -0.00020668463548645377,
     |                          -0.48725831508636475
     |                      ],
     |                      [
     |                          0.5190337951593321,
     |                          -0.1969996948428492,
     |                          0.23267853691809767,
     |                          3.1414194107055664,
     |                          -0.00017726201622281224,
     |                          -0.48750609159469604
     |                      ]
     |                  ],
     |                  "current_joint_angles": r.get_current_joint_angles(),
     |                  "weaving":False,
     |                  "pattern": 1,
     |                  "amplitude_left": 0.003,
     |                  "amplitude_right": 0.003,
     |                  "frequency": 1.5,
     |                  "dwell_time_left": 0.0,
     |                  "dwell_time_right": 0.0,
     |                  "elevation": 0.0,
     |                  "azimuth": 0.0
     |              }
     |              r.move_circular(**circular_property)
     |              r.stop() # if there are multiple motions than,this needs to be called only once at the end of the script
     |      
     |          Example 2:
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |      
     |                  r = Robot()
     |                  r.move_circular(["P1", "P2", "P3"])
     |                  r.stop()
     |  
     |  move_composite(self, *args, **kwargs)
     |      To move the robot in the specified linear and circular motion combinations.
     |      
     |      :param commands: List of linear and circular command combinations.
     |      
     |          linear command:
     |          - targets: list of target poses
     |      
     |          circular command:
     |          - targets: list of target poses
     |      
     |      (type: Pose configuration - [X,Y,Z,R,P,Y], float, units: Position values in meters and rotation values in radians, required: Yes)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: STATIC_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param weaving: Toogle if Weaving should be used for the Motion(type: Bool, units: N/A, default_value: False, required: No)
     |          
     |          True - Weaving is turned on, motion inside are exeuted with given weaving parameters
     |          False - Weaving is turned off, motion does not include Weaving
     |      
     |      :para pattern: The Pattern which should be used for the Weaving (type: Int, units: N/A, default_value: 2, required: No)
     |      
     |          1 - SINE, if selected uses a Sine wave, ignores dwell times
     |          2 - TRAPEZOIDAL, if selected uses a trapezoidal wave, implements dwell times
     |          3 - CIRCLE (experimental), if selected uses a circle wave, ignores dwell time and amplitude offset
     |      
     |      :param amplitude_left: The amplitude on the left side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param amplitude_right: The amplitude on the right side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param frequency: the frequency for the wave form (type: Float, units: Hz, default_value: 10.0, required: No)
     |      
     |      :param dwell_time_left: the wait time, for trapezoidal waves at each peak (left defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param dwell_time_right: the wait time, for trapezoidal waves at each peak (right defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param elevation: the rotation around the velocity vector (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param azimuth: the rotation around the z-Axis of the tool (type: Float, units: rads, default_value: 0.0, required: No)    
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              composite_motion_property = {
     |                  "speed": 0.25,
     |                  "acceleration": 0.1,
     |                  "jerk": 100,
     |                  "rotation_speed": 1.57,
     |                  "rotation_acceleration": 5.0,
     |                  "rotation_jerk": 100,
     |                  "blending_mode": 2,
     |                  "blend_radius": 0.005,
     |                  "current_joint_angles": r.get_current_joint_angles(),
     |                  "commands": [
     |                      {
     |                          "linear": {
     |                              "targets": [
     |                                  [
     |                                      -0.000259845199876027,
     |                                      -0.5211437049195536,
     |                                      0.4429382717719519,
     |                                      3.14123272895813,
     |                                      -0.0007908568368293345,
     |                                      -1.570908784866333
     |                                  ],
     |                                  [
     |                                      -0.16633498440272945,
     |                                      -0.5201452059140722,
     |                                      0.4427486025872017,
     |                                      3.140937089920044,
     |                                      -0.0005319403717294335,
     |                                      -1.571555495262146
     |                                  ]
     |                              ]
     |                          }
     |                      },
     |                      {
     |                          "circular": {
     |                              "targets": [
     |                                  [
     |                                      -0.16633498440272945,
     |                                      -0.5201452059140722,
     |                                      0.4427486025872017,
     |                                      3.140937089920044,
     |                                      -0.0005319403717294335,
     |                                      -1.571555495262146
     |                                  ],
     |                                  [
     |                                      -0.16540090985202305,
     |                                      -0.3983552679378624,
     |                                      0.44267608017426174,
     |                                      3.1407113075256348,
     |                                      -0.00036628879024647176,
     |                                      -1.5714884996414185
     |                                  ],
     |                                  [
     |                                      -0.33446498807559716,
     |                                      -0.3989652352814891,
     |                                      0.4421152856242009,
     |                                      3.1402060985565186,
     |                                      0.00030071483342908323,
     |                                      -1.572899580001831
     |                                  ]
     |                              ]
     |                          }
     |                      }
     |                  ],
     |                  "weaving":False,
     |                  "pattern": 1,
     |                  "amplitude_left": 0.003,
     |                  "amplitude_right": 0.003,
     |                  "frequency": 1.5,
     |                  "dwell_time_left": 0.0,
     |                  "dwell_time_right": 0.0,
     |                  "elevation": 0.0,
     |                  "azimuth": 0.0
     |              }
     |              r.move_composite(**composite_motion_property)
     |              r.stop() # if there are multiple motions than,this needs to be called only once at the end of the script
     |  
     |  move_joint(self, *args, **kwargs)
     |      To move the robot to specified joint configuration in joint space. 
     |      
     |      :param target_joint: List of joint configurations (type: List of Joint Values - float or int, units: radians, required: Yes) Alternative: (List of) String (type: String, name of existing point)
     |      
     |      :param speed: Angular Speed. (type: float, units: % of maximum angular speed, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Angular Acceleration. (type: float, units: % of maximum angular acceleration, default_value: 0.25, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :param enable_blending: Allows to switch between blending and non blending mode. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          If set to True - Joint Motion does not stop at every point
     |          If set to False - Joint Motion stops at every point.
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |              
     |      Sample Usage:
     |      
     |          Example 1:
     |          
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              joint_property = {
     |                  "speed": 50.0,
     |                  "acceleration": 50.0,
     |                  "safety_toggle": True,
     |                  "target_joint": [
     |                      [
     |                          2.5995838308821924,
     |                          0.24962416292345468,
     |                          -1.8654403327490414,
     |                          0.04503286318691005,
     |                          -1.1740563715454926,
     |                          0.10337461241185522
     |                      ],
     |                      [
     |                          2.1372059994827075,
     |                          0.24939733788589463,
     |                          -1.8651270179353125,
     |                          0.044771940725327274,
     |                          -1.173860821592129,
     |                          0.10315646291502645
     |                      ],
     |                      [
     |                          1.9180047887810003,
     |                          -0.24855170101601043,
     |                          -1.3680228668892351,
     |                          0.12404421791100637,
     |                          -1.1914147150222498,
     |                          -0.13255713717112075
     |                      ]
     |                  ],
     |                  "current_joint_angles":  r.get_current_joint_angles()
     |              }
     |              r.move_joint(**joint_property)
     |              r.stop() # if there are multiple motions than,this needs to be called only once at the end of the script
     |      
     |          Example 2:
     |          
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.move_joint("Home")
     |              r.move_joint(["P1", "P2"])
     |              r.stop()
     |  
     |  move_joint_relative(self, *args, **kwargs)
     |      To move the robot relative from the current joint angles by offset.
     |      
     |      :param speed: Angular Speed. (type: float, units: % of maximum angular speed, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Angular Acceleration. (type: float, units: % of maximum angular acceleration, default_value: 0.25, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param offset_frame: The frame in which the offset should be applied to. (type: str - "Base"/"Tool", units: N/A, default_value: "Base", required: No)
     |      
     |      :param cartesian_offset: The cartesian offset that is applied. (type: list - [X,Y,Z,R,P,Y], units: [X,Y,Z] in m - [R,P,Y] in radian, default_value: [0.0,0.0,0.0,0.0,0.0,0.0], required: Yes)
     |      
     |      :param target_joint: The joint configuration at which the relative motion should start from (type: list - [a1, a2, a3, a4, a5, a6] for lara and [a1, a2, a3, a4, a5, a6, a7] for maira, units: axis values in radian, default: current joint angles, required: No)
     |      
     |          If the target_joint is used, the target_pose also needs to be configured, else the current joint angles and current pose are used
     |      
     |      :param target_pose: The pose at which the relative motion should start from (type: list - [X,Y,Z,R,P,Y], units: [X,Y,Z] in m and [R,P,Y] in radian, default: current pose, required: No)
     |      
     |          If the target_pose is used, the target_joint also needs to be configured, else the current joint angle and current pose are used
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :param enable_blending: Allows to switch between blending and non blending mode. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          If set to True - Joint Motion does not stop at every point
     |          If set to False - Joint Motion stops at every point.
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          import math
     |          from neurapy.robot import Robot
     |          r = Robot()
     |      
     |          joint_property = {
     |          "speed" : 50.0,
     |          "acceleration" : 50,
     |          "enable_blending" : False,
     |          "offset_frame" : "Base",
     |          "cartesian_offset" : [0.0, 0.0, 0.1, 0.0, 0.0, math.pi / 4],
     |          "stored_id": 1,
     |          "current_joint_angles": r.get_current_joint_angles()
     |          }
     |      
     |          r.move_joint_relative(**joint_property)
     |          r.stop() # if there are multiple motions than,this needs to be called only once at the end of the script
     |  
     |  move_linear(self, *args, **kwargs)
     |      To move the robot to specified poses in Cartesian/Task space. 
     |      
     |      :param target_pose: List of pose configurations. (type: Pose configuration - [X,Y,Z,R,P,Y], float, units: Position values in meters and rotation values in radians, required: Yes) Alternative: List of Strings (type: [String], names of existing points)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending: Blending. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          True - Blending is turned on, motions inside are executed with given blending mode.
     |          False - Blending is turned off, motions stop at each point.
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: NO_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param weaving: Toogle if Weaving should be used for the Motion(type: Bool, units: N/A, default_value: False, required: No)
     |          
     |          True - Weaving is turned on, motion inside are exeuted with given weaving parameters
     |          False - Weaving is turned off, motion does not include Weaving
     |      
     |      :para pattern: The Pattern which should be used for the Weaving (type: Int, units: N/A, default_value: 2, required: No)
     |      
     |          1 - SINE, if selected uses a Sine wave, ignores dwell times
     |          2 - TRAPEZOIDAL, if selected uses a trapezoidal wave, implements dwell times
     |          3 - CIRCLE (experimental), if selected uses a circle wave, ignores dwell time and amplitude offset
     |      
     |      :param amplitude_left: The amplitude on the left side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param amplitude_right: The amplitude on the right side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param frequency: the frequency for the wave form (type: Float, units: Hz, default_value: 10.0, required: No)
     |      
     |      :param dwell_time_left: the wait time, for trapezoidal waves at each peak (left defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param dwell_time_right: the wait time, for trapezoidal waves at each peak (right defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param elevation: the rotation around the velocity vector (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param azimuth: the rotation around the z-Axis of the tool (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          Example 1:
     |          
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              linear_property = {
     |                  "speed": 0.25,
     |                  "acceleration": 0.1,
     |                  "rotation_speed": 0.5,
     |                  "blending": True,
     |                  "blending_mode": 2.
     |                  "blend_radius": 0.005,
     |                  "target_pose": [
     |                      [
     |                          0.3287228886,
     |                          -0.1903355329,
     |                          0.4220780352,
     |                          0.08535207028439847,
     |                          -2.797181496822229,
     |                          2.4713321627410485
     |                      ],
     |                      [
     |                          0.2093363791501374,
     |                          -0.31711250784165884,
     |                          0.422149168855134,
     |                          -3.0565555095672607,
     |                          -0.3447442352771759,
     |                          -1.1323236227035522
     |                      ],
     |                      [
     |                          0.2090521916195534,
     |                          -0.5246753336643587,
     |                          0.4218773613553828,
     |                          -3.0569007396698,
     |                          -0.3448921740055084,
     |                          -1.1323626041412354
     |                      ],
     |                      [
     |                          0.3287228886,
     |                          -0.1903355329,
     |                          0.4220780352,
     |                          0.08535207028439847,
     |                          -2.797181496822229,
     |                          2.4713321627410485
     |                      ]
     |                  ],
     |                  "current_joint_angles":  r.get_current_joint_angles(),
     |                  "weaving":False,
     |                  "pattern": 1,
     |                  "amplitude_left": 0.003,
     |                  "amplitude_right": 0.003,
     |                  "frequency": 1.5,
     |                  "dwell_time_left": 0.0,
     |                  "dwell_time_right": 0.0,
     |                  "elevation": 0.0,
     |                  "azimuth": 0.0
     |              }
     |              r.move_linear(**linear_property)
     |              r.stop() # if there are multiple motions than,this needs to be called only once at the end of the script
     |      
     |          Example 2:
     |          
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |      
     |                  r = Robot()
     |                  r.move_linear(["P1", "P2"])
     |                  r.stop()
     |  
     |  move_linear_from_current_position(self, *args, **kwargs)
     |      To move the robot from current position to the specified target pose/s.Unlike move_linear, current position is added as the first target in this function.
     |      
     |      :param target_pose: List of pose configurations. (type: Pose configuration - [X,Y,Z,R,P,Y], float, units: Position values in meters and rotation values in radians, required: Yes)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending: Blending. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          True - Blending is turned on, motions inside are executed with given blending mode.
     |          False - Blending is turned off, motions stop at each point.
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: NO_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param weaving: Toogle if Weaving should be used for the Motion(type: Bool, units: N/A, default_value: False, required: No)
     |          
     |          True - Weaving is turned on, motion inside are exeuted with given weaving parameters
     |          False - Weaving is turned off, motion does not include Weaving
     |      
     |      :para pattern: The Pattern which should be used for the Weaving (type: Int, units: N/A, default_value: 2, required: No)
     |      
     |          1 - SINE, if selected uses a Sine wave, ignores dwell times
     |          2 - TRAPEZOIDAL, if selected uses a trapezoidal wave, implements dwell times
     |          3 - CIRCLE (experimental), if selected uses a circle wave, ignores dwell time and amplitude offset
     |      
     |      :param amplitude_left: The amplitude on the left side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param amplitude_right: The amplitude on the right side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param frequency: the frequency for the wave form (type: Float, units: Hz, default_value: 10.0, required: No)
     |      
     |      :param dwell_time_left: the wait time, for trapezoidal waves at each peak (left defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param dwell_time_right: the wait time, for trapezoidal waves at each peak (right defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param elevation: the rotation around the velocity vector (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param azimuth: the rotation around the z-Axis of the tool (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              linear_property = {
     |                  "speed": 0.25,
     |                  "acceleration": 0.1,
     |                  "jerk": 100,
     |                  "rotation_speed": 1.57,
     |                  "rotation_acceleration": 5.0,
     |                  "rotation_jerk": 100,
     |                  "blending": True,
     |                  "blending_mode": 1,
     |                  "blend_radius": 0.005,
     |                  "target_pose": [
     |                      [
     |                          0.3287228886,
     |                          -0.1903355329,
     |                          0.4220780352,
     |                          0.08535207028439847,
     |                          -2.797181496822229,
     |                          2.4713321627410485
     |                      ]
     |                  ],
     |                  "current_joint_angles":  r.get_current_joint_angles(),
     |                  "weaving":False,
     |                  "pattern": 1,
     |                  "amplitude_left": 0.003,
     |                  "amplitude_right": 0.003,
     |                  "frequency": 1.5,
     |                  "dwell_time_left": 0.0,
     |                  "dwell_time_right": 0.0,
     |                  "elevation": 0.0,
     |                  "azimuth": 0.0
     |              }
     |              r.move_linear_from_current_position(**linear_property)
     |              r.stop() # if there are multiple motions than,this needs to be called only once at the end of the script
     |  
     |  move_linear_relative(self, *args, **kwargs)
     |      To move the robot relative to the current position by the given offset.
     |      
     |      :param cartesian_offset: (type: offset list - [X,Y,Z,R,P,Y], units: [X,Y,Z] offset in m [R,P,Y] offset in radian, default: [.0,.0,.0,.0,.0,.0], required: Yes)
     |      
     |      :param offset_frame: (type: string, units: N/A, default_value: "Base", required: No)
     |      
     |          "Base" - Applies relative offset to the base frame
     |          "Tool" - Applies relative offset to the tool frame
     |      
     |      :param target_pose: The pose at which the relative motion should start from (type: list - [X,Y,Z,R,P,Y], units: [X,Y,Z] in m and [R,P,Y] in radian, default: current pose, required: No)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending: Blending. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          True - Blending is turned on, motions inside are executed with given blending mode.
     |          False - Blending is turned off, motions stop at each point.
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: NO_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |          .. code-block:: python
     |              import math
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |      
     |              linear_property = {
     |                  "speed" : 4.5,
     |                  "acceleration" : 10.0,
     |                  "jerk": 1000.0,
     |                  "rotation_speed" : 1.5,
     |                  "rotation_acceleration" : 10.0,
     |                  "rotation_jerk" : 1000.0,
     |                  "weaving" : False,
     |                  "enable_blending" : False,
     |                  "offset_frame" : "Base",
     |                  "cartesian_offset" : [0.0, 0.0, 0.1, 0.0, 0.0, math.pi/4],
     |                  "stored_id": 1,
     |                  "current_joint_angles": r.get_current_joint_angles()
     |              }
     |              r.move_linear(**linear_property)
     |              r.stop() # only needs to be executed at the end of the program
     |  
     |  move_trajectory(self, *args, **kwargs)
     |      Move the robot with a given joint trajectory.
     |      
     |      Parameters:
     |      
     |      timestamps : list of float
     |          List of times at which the joint configurations should be reached (units: sec).
     |      
     |      target_joint : list of float
     |          List of joint configurations (units: radians).
     |      
     |      current_joint_angles : list of float, optional
     |          Current Robot Joint Configuration. If not provided, it will be obtained from Robot Status method.
     |      
     |      Returns:
     |          bool: True if the motion is executed successfully, False if not.
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              trajectory_motion_property = {
     |                "current_joint_angles": r.get_current_joint_angles(),
     |                "timestamps": [
     |                  0.01, 0.02, 0.03
     |                ],
     |                "target_joint": [
     |                  [0.0531381, 0.157485, -0.100272, 1.29569, -5.99211e-05, 0.700957,-0.000371511],
     |                  [-0.208897,0.461728,-0.433937,1.66485,-5.99211e-05,0.700382,-0.000383495],
     |                  [0.0120801,0.621298,0.0149563,1.67381,5.99211e-05,0.687403,-0.000359527]
     |                ]
     |              }
     |              r.move_trajectory(**trajectory_motion_property)
     |              r.stop() # if there are multiple motions than,this needs to be called only once at the end of the script
     |  
     |  notify_error(self, msg)
     |      To notify an error message to teach pendant .
     |      
     |      :param msg: The error message to be sent.
     |      :type msg: str
     |      :return: True if successful, else False
     |      
     |      Sample Usage:
     |      
     |      .. code-block:: python
     |      
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          if r.notify_error("Something went wrong!"):
     |              print("Error message sent successfully.")
     |          else:
     |              print("Failed to send error message.")
     |  
     |  notify_info(self, msg)
     |      To notify a info message to teach pendant.
     |      
     |      :param msg: The error message to be sent.
     |      :type msg: str
     |      :return: True if successful, else False
     |      
     |      Sample Usage:
     |      
     |      .. code-block:: python
     |      
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          if r.notify_info("This is an info!"):
     |              print("Info message sent successfully.")
     |          else:
     |              print("Failed to send info message.")
     |  
     |  notify_warning(self, msg)
     |      To notify a warning message to teach pendant.
     |      
     |      :param msg: The error message to be sent.
     |      :type msg: str
     |      :return: True if successful, else False
     |      
     |      Sample Usage:
     |      
     |      .. code-block:: python
     |      
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          if r.notify_warning("This is a warning!"):
     |              print("Warning message sent successfully.")
     |          else:
     |              print("Failed to send warning message.")
     |  
     |  override(self, *args, **kwargs)
     |      .. warning::
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`get_override`
     |          - :func:`set_override`
     |          
     |      Set or get the override value on the robot.
     |      
     |      Args:
     |          operation_type (str): The type of operation.
     |              - 'get': Get the current override value.
     |              - 'set': Set the override value.
     |      
     |          target_value (float, optional): The override value. Required only for the 'set' operation.
     |      
     |      Returns:
     |          Union[bool, float]: True or False if the 'set' operation succeeds or fails.
     |              The override value if the 'get' operation succeeds.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              override_value = r.override("get")
     |              print("override_value : " + str(override_value))
     |              time.sleep(1)
     |      
     |              override_value = r.override("set", target_value = 0.4)
     |              print("Setting Override to 0.4")
     |              time.sleep(1)
     |      
     |              override_value = r.override("get")
     |              print("override_value : " + str(override_value))
     |  
     |  pause(self, *args, **kwargs)
     |      To pause the robot's motion.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.pause()
     |  
     |  plan_joint_trajectory(self, *args, **kwargs)
     |      To plan the given joint trajectory.
     |      
     |      Parameters:
     |      
     |      timestamps : list of float
     |          List of times at which the joint configurations should be reached (units: sec).
     |      
     |      target_joint : list of float
     |          List of joint configurations (units: radians).
     |      
     |      current_joint_angles : list of float, optional
     |          Current Robot Joint Configuration. If not provided, it will be obtained from Robot Status method.
     |      
     |      :param store_id: identifier to the stored plan. (type: int , if not provided a random will be assigned, which will be returned after the function execution)
     |      
     |      :return: plan_id (equal to store_id if provided in inputs, else an identifier function has generated to store the plan)
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              trajectory_motion_property = {
     |                "current_joint_angles": r.get_current_joint_angles(),
     |                "timestamps": [
     |                  0.01, 0.02, 0.03
     |                ],
     |                "target_joint": [
     |                  [0.0531381, 0.157485, -0.100272, 1.29569, -5.99211e-05, 0.700957,-0.000371511],
     |                  [-0.208897,0.461728,-0.433937,1.66485,-5.99211e-05,0.700382,-0.000383495],
     |                  [0.0120801,0.621298,0.0149563,1.67381,5.99211e-05,0.687403,-0.000359527]
     |                ]
     |              }
     |              plan_id = r.plan_move_trajectory(**trajectory_motion_property)
     |              execute = r.executor([plan_id])
     |  
     |  plan_move_circular(self, *args, **kwargs)
     |      To plan a circular path across the given poses. This method takes the following arguments/keyword arguments:
     |      
     |      :param target_pose: List of 3 pose configurations (starting, middle, and end points). (type: Pose configuration - [X,Y,Z,R,P,Y], float, units: Position values in meters and rotation values in radians, required: Yes)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: DYNAMIC_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param weaving: Toogle if Weaving should be used for the Motion(type: Bool, units: N/A, default_value: False, required: No)
     |          
     |          True - Weaving is turned on, motion inside are exeuted with given weaving parameters
     |          False - Weaving is turned off, motion does not include Weaving
     |      
     |      :para pattern: The Pattern which should be used for the Weaving (type: Int, units: N/A, default_value: 2, required: No)
     |      
     |          1 - SINE, if selected uses a Sine wave, ignores dwell times
     |          2 - TRAPEZOIDAL, if selected uses a trapezoidal wave, implements dwell times
     |          3 - CIRCLE (experimental), if selected uses a circle wave, ignores dwell time and amplitude offset
     |      
     |      :param amplitude_left: The amplitude on the left side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param amplitude_right: The amplitude on the right side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param frequency: the frequency for the wave form (type: Float, units: Hz, default_value: 10.0, required: No)
     |      
     |      :param dwell_time_left: the wait time, for trapezoidal waves at each peak (left defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param dwell_time_right: the wait time, for trapezoidal waves at each peak (right defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param elevation: the rotation around the velocity vector (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param azimuth: the rotation around the z-Axis of the tool (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |          
     |      :param store_id: identifier to the stored plan. (type: int , if not provided a random will be assigned, which will be returned after the function execution)
     |      
     |      Return Values:
     |      
     |      :return: plan_id (equal to store_id if provided in inputs, else an identifier function has generated to store the plan)
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              circular_property = {
     |                  "speed": 0.25,
     |                  "acceleration": 0.1,
     |                  "jerk": 100,
     |                  "rotation_speed": 1.57,
     |                  "rotation_acceleration": 5.0,
     |                  "rotation_jerk": 100,
     |                  "blending_mode": 2,
     |                  "blend_radius": 0.05,
     |                  "target_pose": [
     |                      [
     |                          0.3744609827431085,
     |                          -0.3391784988266481,
     |                          0.23276604279256016,
     |                          3.14119553565979,
     |                          -0.00017731254047248513,
     |                          -0.48800110816955566
     |                      ],
     |                      [
     |                          0.37116786741831503,
     |                          -0.19686307684994242,
     |                          0.23300456855796453,
     |                          3.141423225402832,
     |                          -0.00020668463548645377,
     |                          -0.48725831508636475
     |                      ],
     |                      [
     |                          0.5190337951593321,
     |                          -0.1969996948428492,
     |                          0.23267853691809767,
     |                          3.1414194107055664,
     |                          -0.00017726201622281224,
     |                          -0.48750609159469604
     |                      ]
     |                  ],
     |                  "store_id":234,
     |                  "current_joint_angles": r.get_current_joint_angles(),
     |                  "weaving":False,
     |                  "pattern": 1,
     |                  "amplitude_left": 0.003,
     |                  "amplitude_right": 0.003,
     |                  "frequency": 1.5,
     |                  "dwell_time_left": 0.0,
     |                  "dwell_time_right": 0.0,
     |                  "elevation": 0.0,
     |                  "azimuth": 0.0
     |              }
     |              plan_id = r.plan_move_circular(**circular_property)
     |              execute = r.executor([plan_id])
     |  
     |  plan_move_composite(self, *args, **kwargs)
     |      To plan move composite across the given poses. This method takes the following arguments/keyword arguments:
     |      
     |      To move the robot in the specified linear and circular motion combinations.
     |      
     |      :param commands: List of linear and circular command combinations.
     |      
     |          linear command:
     |          - targets: list of target poses
     |      
     |          circular command:
     |          - targets: list of target poses
     |      
     |      (type: Pose configuration - [X,Y,Z,R,P,Y], float, units: Position values in meters and rotation values in radians, required: Yes)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: STATIC_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param weaving: Toogle if Weaving should be used for the Motion(type: Bool, units: N/A, default_value: False, required: No)
     |          
     |          True - Weaving is turned on, motion inside are exeuted with given weaving parameters
     |          False - Weaving is turned off, motion does not include Weaving
     |      
     |      :para pattern: The Pattern which should be used for the Weaving (type: Int, units: N/A, default_value: 2, required: No)
     |      
     |          1 - SINE, if selected uses a Sine wave, ignores dwell times
     |          2 - TRAPEZOIDAL, if selected uses a trapezoidal wave, implements dwell times
     |          3 - CIRCLE (experimental), if selected uses a circle wave, ignores dwell time and amplitude offset
     |      
     |      :param amplitude_left: The amplitude on the left side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param amplitude_right: The amplitude on the right side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param frequency: the frequency for the wave form (type: Float, units: Hz, default_value: 10.0, required: No)
     |      
     |      :param dwell_time_left: the wait time, for trapezoidal waves at each peak (left defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param dwell_time_right: the wait time, for trapezoidal waves at each peak (right defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param elevation: the rotation around the velocity vector (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param azimuth: the rotation around the z-Axis of the tool (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :param store_id: identifier to the stored plan. (type: int , if not provided a random will be assigned, which will be returned after the function execution)
     |      
     |      :return: plan_id (equal to store_id if provided in inputs, else an identifier function has generated to store the plan)
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              composite_motion_property = {
     |                  "speed": 0.25,
     |                  "acceleration": 0.1,
     |                  "jerk": 100,
     |                  "rotation_speed": 1.57,
     |                  "rotation_acceleration": 5.0,
     |                  "rotation_jerk": 100,
     |                  "blending_mode": 1,
     |                  "blend_radius": 0.01,
     |                  "current_joint_angles": r.get_current_joint_angles(),
     |                  "commands": [
     |                      {
     |                          "linear": {
     |                              "blend_radius": 0.005,
     |                              "targets": [
     |                                  [
     |                                      -0.000259845199876027,
     |                                      -0.5211437049195536,
     |                                      0.4429382717719519,
     |                                      3.14123272895813,
     |                                      -0.0007908568368293345,
     |                                      -1.570908784866333
     |                                  ],
     |                                  [
     |                                      -0.16633498440272945,
     |                                      -0.5201452059140722,
     |                                      0.4427486025872017,
     |                                      3.140937089920044,
     |                                      -0.0005319403717294335,
     |                                      -1.571555495262146
     |                                  ]
     |                              ]
     |                          }
     |                      },
     |                      {
     |                          "circular": {
     |                              "targets": [
     |                                  [
     |                                      -0.16633498440272945,
     |                                      -0.5201452059140722,
     |                                      0.4427486025872017,
     |                                      3.140937089920044,
     |                                      -0.0005319403717294335,
     |                                      -1.571555495262146
     |                                  ],
     |                                  [
     |                                      -0.16540090985202305,
     |                                      -0.3983552679378624,
     |                                      0.44267608017426174,
     |                                      3.1407113075256348,
     |                                      -0.00036628879024647176,
     |                                      -1.5714884996414185
     |                                  ],
     |                                  [
     |                                      -0.33446498807559716,
     |                                      -0.3989652352814891,
     |                                      0.4421152856242009,
     |                                      3.1402060985565186,
     |                                      0.00030071483342908323,
     |                                      -1.572899580001831
     |                                  ]
     |                              ]
     |                          }
     |                      }
     |                  ],
     |                  "store_id":234,
     |                  "current_joint_angles": r.get_current_joint_angles(),
     |                  "weaving":False,
     |                  "pattern": 1,
     |                  "amplitude_left": 0.003,
     |                  "amplitude_right": 0.003,
     |                  "frequency": 1.5,
     |                  "dwell_time_left": 0.0,
     |                  "dwell_time_right": 0.0,
     |                  "elevation": 0.0,
     |                  "azimuth": 0.0
     |              }
     |              plan_id= r.plan_move_composite(**composite_motion_property)
     |              execute = r.executor([plan_id])
     |  
     |  plan_move_joint(self, *args, **kwargs)
     |      To plan a joint space motion across the given configurations. This method takes the following arguments/keyword arguments:
     |      
     |      To move the robot to specified joint configuration in joint space. 
     |      
     |      :param target_joint: List of joint configurations. (type: List of Joint Values - float, units: radians, required: Yes)
     |      
     |      :param speed: Angular Speed. (type: float, units: % of maximum angular speed, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Angular Acceleration. (type: float, units: % of maximum angular acceleration, default_value: 0.25, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :param enable_blending: Allows to switch between blending and non blending mode. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          If set to True - Joint Motion does not stop at every point
     |          If set to False - Joint Motion stops at every point.
     |      
     |      :param store_id: identifier to the stored plan. (type: int , if not provided a random will be assigned, which will be returned after the function execution)
     |      
     |      :return: plan_id (equal to store_id if provided in inputs, else an identifier function has generated to store the plan)
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |              
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |      
     |                  r = Robot()
     |                  joint_property = {
     |                      "speed": 50.0,
     |                      "acceleration": 50.0,
     |                      "safety_toggle": True,
     |                      "enable_blending": True,
     |                      "target_joint": [
     |                          [
     |                              2.5995838308821924,
     |                              0.24962416292345468,
     |                              -1.8654403327490414,
     |                              0.04503286318691005,
     |                              -1.1740563715454926,
     |                              0.10337461241185522
     |                          ],
     |                          [
     |                              2.1372059994827075,
     |                              0.24939733788589463,
     |                              -1.8651270179353125,
     |                              0.044771940725327274,
     |                              -1.173860821592129,
     |                              0.10315646291502645
     |                          ],
     |                          [
     |                              1.9180047887810003,
     |                              -0.24855170101601043,
     |                              -1.3680228668892351,
     |                              0.12404421791100637,
     |                              -1.1914147150222498,
     |                              -0.13255713717112075
     |                          ]
     |                      ],
     |                      "store_id":234,
     |                      "current_joint_angles":  r.get_current_joint_angles()
     |                  }
     |                  plan_id =r.plan_move_joint(**joint_property)
     |                  execute = r.executor([plan_id])
     |  
     |  plan_move_joint_relative(self, *args, **kwargs)
     |      To plan a relative motion from current joint angles by offset. Between planning and executing no other motion should be executed, because the motion gets planned from the 
     |      current position at plan time. If this is done, a closing of the gap takes place and the robot moves back to the position where the motion was planned at.
     |      
     |      :param speed: Angular Speed. (type: float, units: % of maximum angular speed, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Angular Acceleration. (type: float, units: % of maximum angular acceleration, default_value: 0.25, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param offset_frame: The frame in which the offset should be applied to. (type: str - "Base"/"Tool", units: N/A, default_value: "Base", required: No)
     |      
     |      :param cartesian_offset: The cartesian offset that is applied. (type: list - [X,Y,Z,R,P,Y], units: [X,Y,Z] in m - [R,P,Y] in radian, default_value: [0.0,0.0,0.0,0.0,0.0,0.0], required: Yes)
     |      
     |      :param target_joint: The joint configuration at which the relative motion should start from (type: list - [a1, a2, a3, a4, a5, a6] for lara and [a1, a2, a3, a4, a5, a6, a7] for maira, units: axis values in radian, default: current joint angles, required: No)
     |      
     |          If the target_joint is used, the target_pose also needs to be configured, else the current joint angles and current pose are used
     |      
     |      :param target_pose: The pose at which the relative motion should start from (type: list - [X,Y,Z,R,P,Y], units: [X,Y,Z] in m and [R,P,Y] in radian, default: current pose, required: No)
     |      
     |          If the target_pose is used, the target_joint also needs to be configured, else the current joint angle and current pose are used
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :param enable_blending: Allows to switch between blending and non blending mode. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          If set to True - Joint Motion does not stop at every point
     |          If set to False - Joint Motion stops at every point.
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          import math
     |          from neurapy.robot import Robot
     |          r = Robot()
     |      
     |          joint_property = {
     |          "speed" : 50.0,
     |          "acceleration" : 50,
     |          "enable_blending" : False,
     |          "offset_frame" : "Tool",
     |          "relative_offset" : [0.0, 0.0, 0.1, 0.0, 0.0, math.pi / 4],
     |          "stored_id": 1,
     |          "current_joint_angles": r.get_current_joint_angles()
     |          }
     |      
     |          plan_id = r.plan_move_joint_relative(**joint_property)
     |          execution = r.execute([plan_id])
     |  
     |  plan_move_linear(self, *args, **kwargs)
     |      To plan a move linear path across the given poses. This method takes the following arguments/keyword arguments:
     |      
     |      To move the robot to specified poses in Cartesian/Task space. 
     |      
     |      :param target_pose: List of pose configurations. (type: Pose configuration - [X,Y,Z,R,P,Y], float, units: Position values in meters and rotation values in radians, required: Yes)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending: Blending. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          True - Blending is turned on, motions inside are executed with given blending mode.
     |          False - Blending is turned off, motions stop at each point.
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: NO_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Value of the blend radius, if blending is needed between two segments of motion. (type: float, units: meters, default_value: 0, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param weaving: Toogle if Weaving should be used for the Motion(type: Bool, units: N/A, default_value: False, required: No)
     |          
     |          True - Weaving is turned on, motion inside are exeuted with given weaving parameters
     |          False - Weaving is turned off, motion does not include Weaving
     |      
     |      :para pattern: The Pattern which should be used for the Weaving (type: Int, units: N/A, defualt_value: 2, required: No)
     |      
     |          1 - SINE, if selected uses a Sine wave, ignores dwell times
     |          2 - TRAPEZOIDAL, if selected uses a trapezoidal wave, implements dwell times
     |          3 - CIRCLE (experimental), if selected uses a circle wave, ignores dwell time and amplitude offset
     |      
     |      :param amplitude_left: The amplitude on the left side (defined in motion direction) (type: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param amplitude_right: The amplitude on the right side (defined in motion direction) (tpye: Float, units: m, default_value: 0.0, required: No)
     |      
     |      :param frequency: the frequency for the wave form (tpye: Float, units: Hz, default_value: 10.0, required: No)
     |      
     |      :param dwell_time_left: the wait time, for trapezoidal waves at each peak (left defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param dwell_time_right: the wait time, for trapezoidal waves at each peak (right defined by motion direction) (type: Float, units: s, default_value: 0.0, required: No)
     |      
     |      :param elevation: the rotation around the velocity vector (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param azimuth: the rotation around the z-Axis of the tool (type: Float, units: rads, default_value: 0.0, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :param store_id: identifier to store the plan. (type: int , if not provided a random will be assigned, which will be returned after the function execution)
     |      
     |      :return: plan_id (equal to store_id if provided in inputs, else an identifier function has generated to store the plan)
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |              linear_property = {
     |                  "speed": 0.25,
     |                  "acceleration": 0.1,
     |                  "jerk": 100,
     |                  "rotation_speed": 1.57,
     |                  "rotation_acceleration": 5.0,
     |                  "rotation_jerk": 100,
     |                  "blending": True,
     |                  "blending_mode": 2,
     |                  "blend_radius": 0.01,
     |                  "target_pose": [
     |                      [
     |                          0.3287228886,
     |                          -0.1903355329,
     |                          0.4220780352,
     |                          0.08535207028439847,
     |                          -2.797181496822229,
     |                          2.4713321627410485
     |                      ],
     |                      [
     |                          0.2093363791501374,
     |                          -0.31711250784165884,
     |                          0.422149168855134,
     |                          -3.0565555095672607,
     |                          -0.3447442352771759,
     |                          -1.1323236227035522
     |                      ],
     |                      [
     |                          0.2090521916195534,
     |                          -0.5246753336643587,
     |                          0.4218773613553828,
     |                          -3.0569007396698,
     |                          -0.3448921740055084,
     |                          -1.1323626041412354
     |                      ],
     |                      [
     |                          0.3287228886,
     |                          -0.1903355329,
     |                          0.4220780352,
     |                          0.08535207028439847,
     |                          -2.797181496822229,
     |                          2.4713321627410485
     |                      ]
     |                  ],
     |                  "store_id":234,
     |                  "current_joint_angles":  r.get_current_joint_angles(),
     |                  "weaving":False,
     |                  "pattern": 1,
     |                  "amplitude_left": 0.003,
     |                  "amplitude_right": 0.003,
     |                  "frequency": 1.5,
     |                  "dwell_time_left": 0.0,
     |                  "dwell_time_right": 0.0,
     |                  "elevation": 0.0,
     |                  "azimuth": 0.0
     |              }
     |              plan_id = r.plan_move_linear(**linear_property)
     |              execute_motion = r.executor([plan_id]) #To execute the planned id
     |  
     |  plan_move_linear_relative(self, *args, **kwargs)
     |      To plan a relative motion from current position by offset. Between planning and executing no other motion should be executed, because the motion gets planned from the 
     |      current position at plan time. If this is done, a closing of the gap takes place and the robot moves back to the position where the motion was planned at.
     |      
     |      :param cartesian_offset: (type: offset list - [X,Y,Z,R,P,Y], units: [X,Y,Z] offset in m [R,P,Y] offset in radian, default: [.0,.0,.0,.0,.0,.0], required: Yes)
     |      
     |      :param offset_frame: (type: string, units: N/A, default_value: "Base", required: No)
     |      
     |      :param speed: Translation Speed. (type: float, units: m/sec, default_value: 0.25, required: No)
     |      
     |      :param acceleration: Translation Acceleration. (type: float, units: m/sec2, default_value: 0.25, required: No)
     |      
     |      :param jerk: Translation Jerk (type: float, units: m/sec3, default_value: 500.0, required: No)
     |      
     |      :param rotation_speed: Rotational Speed. (type: float, units: rad/sec, default_value: 0.5, required: No)
     |      
     |      :param rotation_acceleration: Rotational Acceleration. (type: float, units: rad/sec2, default_value: 1.57, required: No)
     |      
     |      :param rotation_jerk: Rotational Jerk. (type: float, units: rad/sec3, default_value: 500.0, required: No)
     |      
     |      :param blending: Blending. (type: Bool - True/False, units: N/A, default_value: False, required: No)
     |      
     |          True - Blending is turned on, motions inside are executed with given blending mode.
     |          False - Blending is turned off, motions stop at each point.
     |      
     |      :param blending_mode: The blending type that is selected to blend between points. (type: enum, units: N/A, default_value: NO_BLENDING, required: No)
     |      
     |          0 - NO_BLENDING, if selected goes to the default blending mode.
     |          1 - DYNAMIC_BLENDING, blending based on velocity and acceleration.
     |          2 - STATIC_BLENDING, blending based on the given blend_radius.
     |      
     |      :param blend_radius: Blend Radius, if static blending is selected. (type: float, units: m, default_value: 0.01, required: No)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |      
     |      Sample Usage:
     |          .. code-block:: python
     |              import math
     |              from neurapy.robot import Robot
     |      
     |              r = Robot()
     |      
     |              linear_property = {
     |                  "speed" : 4.5,
     |                  "acceleration" : 10.0,
     |                  "jerk": 1000.0,
     |                  "rotation_speed" : 1.5,
     |                  "rotation_acceleration" : 10.0,
     |                  "rotation_jerk" : 1000.0,
     |                  "weaving" : False,
     |                  "enable_blending" : False,
     |                  "offset_frame" : "Tool",
     |                  "cartesian_offset" : [0.0, 0.0, 0.1, 0.0, 0.0, math.pi/4],
     |                  "stored_id": 1,
     |                  "current_joint_angles": r.get_current_joint_angles()
     |              }
     |              plan_id = r.plan_move_linear_relative(**linear_property)
     |              execute = r.executor([plan_id])
     |              r.stop() # only needs to be executed at the end of the program
     |  
     |  plan_move_recorded_path(self, *args, **kwargs)
     |      To plan the given pre-recorded path. This method takes the following arguments/keyword arguments:
     |      
     |      :param is_motion: True if constant velocity is needed during the motion. (type: bool, required: Yes)
     |      
     |      :param file_location: Location of the recorded path file. (type: str, required: Yes)
     |      
     |      :param speed: Linear Speed. (type: float, units: m/sec, required: Yes)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      :param store_id: identifier to the stored plan. (type: int , if not provided a random will be assigned, which will be returned after the function execution)
     |      
     |      :return: plan_id (equal to store_id if provided in inputs, else an identifier function has generated to store the plan)
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |  
     |  power(self, *args, **kwargs)
     |      .. warning::
     |      
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`power_on`
     |          - :func:`power_off`
     |      
     |      
     |      Turn on/off the power to the robot.
     |      
     |      Args:
     |          value (str): Specifies the power action.
     |              - 'on'  : Power on the robot.
     |              - 'off' : Power off the robot.
     |      
     |      Returns:
     |          bool: True if the operation is executed successfully, False otherwise.
     |      
     |      Sample Usage:
     |              .. code-block:: python
     |      
     |                  from time import sleep
     |                  from neurapy.robot import Robot
     |      
     |                  r = Robot()
     |                  r.power('on')
     |                  sleep(2)
     |                  r.power('off')
     |  
     |  power_off(self)
     |      To power off the robot.
     |      
     |      Returns:
     |          bool: True if the robot's power is successfully turned off, False otherwise.
     |          
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.power_off():
     |                  print("Robot powered off successfully.")
     |              else:
     |                  print("Failed to power off the robot.")
     |  
     |  power_on(self)
     |      To power on the robot.
     |      
     |      Returns:
     |          bool: True if the robot's power is successfully turned on, False otherwise.
     |          
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.power_on():
     |                  print("Robot powered on successfully.")
     |              else:
     |                  print("Failed to power on the robot.")
     |  
     |  program_status(self)
     |      Query the program status of the robot.
     |      
     |      Returns:
     |          str: The program status of the robot.
     |              - 'NOT_RUNNING': If the program is not running from the Teach pendant.
     |              - 'RUNNING'    : If the program is running from the Teach pendant.
     |              - 'PAUSED'     : If the program running from the Teach pendant is in a pause state.
     |      
     |      Sample Usage:
     |      
     |              .. code-block:: python
     |      
     |                      from neurapy.robot import Robot
     |      
     |                      r = Robot()
     |                      print(r.program_status())
     |  
     |  quaternion_to_rpy(self, w, x, y, z)
     |      Convert a quaternion representation to roll-pitch-yaw (RPY) angles.
     |      
     |      Args:
     |          w (float): Scalar component (real) of the quaternion.
     |          x (float): First vector component of the quaternion.
     |          y (float): Second vector component of the quaternion.
     |          z (float): Third vector component of the quaternion.
     |      
     |      Returns:
     |          list: A list containing [roll, pitch, yaw] angles in radians.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              quaternion = r.quaternion_to_rpy(0.85,0,0.52,0)
     |  
     |  read_safeio(self, *args, **kwargs)
     |      Method to read the values of configurable/safe Input/Outputs
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  safe_io = r.read_safeio(1)
     |                  print(safe_io) #True/False
     |  
     |  record_path(self, *args, **kwargs)
     |      To move the robot in a pre-recorded path. This method takes the following arguments/keyword arguments:
     |      
     |      :param is_motion: True if constant velocity is needed during the motion. (type: bool, required: Yes)
     |      
     |      :param file_location: Location of the recorded path file. (type: str, required: Yes)
     |      
     |      :param speed: Linear Speed. (type: float, units: m/sec, required: Yes)
     |      
     |      :param current_joint_angles: Current Robot Joint Configuration. (type: List of Joint Values - float, units: radians, default_value: Joint Configuration obtained from Robot Status method, required: No)
     |      
     |      :param safety_toggle: Safety toggle. (type: Bool - True/False, units: N/A, default_value: value of the safety toggle in Program screen if not set, required: No)
     |      
     |          If set to True, Max speed is slashed to 25%
     |          False - No reduction in already set max speed
     |      
     |      
     |      :return: True if motion is executed successfully, False if motion is not executed successfully
     |      
     |      Raises:
     |      
     |          WrongMode: If the robot is in Teach mode, while executing this function
     |          ConnectionError: If there is a failure to connect to the robot.
     |          UnfeasibleMotion: If motion is not possible with the given input parameters
     |          InterruptedError: If there is any interruption during the execution of the motion
     |  
     |  release(self)
     |      To release the grasped object
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.release()
     |  
     |  remove_load(self)
     |      Remove the load which was set in set_load and set load back to the tool parameters.
     |      
     |      Returns:
     |          List: List containing the updated tool properties. i.e . [tool_mass,roll_offset,pitch_offset,yaw_offset,x_offset,y_offset,z_offset,COG_x,COG_y,COG_z,Ixx,Iyy, Izz, Ixy, Ixz, and Iyz]
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.remove_load()
     |  
     |  reset_collision(self)
     |      Reset the collision state of the robot.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.reset_collision()
     |  
     |  reset_control(self)
     |      To restart the control software running on the robot. Equivalent to reset control option from Teach pendant
     |      
     |      :return: True if the control reset was successful, False otherwise.
     |      :rtype: bool
     |      
     |      Sample Usage:
     |      
     |      .. code-block:: python
     |          
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          if r.reset_control():
     |              print("Control reset successful.")
     |          else:
     |              print("Control reset failed.")
     |  
     |  reset_errors(self, *args, **kwargs)
     |      Method to reset the errors on the robot
     |      
     |      Sample Usage:
     |          
     |          .. code-block:: python
     |          
     |                  import time
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.reset_error()
     |  
     |  reset_warnings(self)
     |      Method to reset/clear the warnings on the robot
     |      
     |      Sample Usage:
     |          
     |          .. code-block:: python
     |          
     |                  import time
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.reset_warnings()
     |  
     |  robot_status(self, *args, **kwargs)
     |      .. warning::
     |      
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`get_current_joint_angles`
     |          - :func:`get_current_joint_angles_with_timestamp`
     |          - :func:`get_current_cartesian_pose`
     |          - :func:`get_current_cartesian_pose_with_timestamp`
     |          - :func:`get_current_joint_torques`
     |          - :func:`get_current_joint_torques_with_timestamp`
     |          - :func:`get_current_joint_torques_with_timestamp`
     |          - :func:`get_current_joint_velocities_with_timestamp`
     |          - :func:`get_current_load_side_encoder_values`
     |          - :func:`get_current_load_side_encoder_values_with_timestamp`
     |          - :func:`get_current_motor_side_encoder_values`
     |          - :func:`get_current_motor_side_encoder_values_with_timestamp`
     |      
     |      
     |      Query the current status of the robot.
     |      
     |      Returns:
     |          Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any], Dict[str, Any], Dict[str, Any], Dict[str, Any]]:
     |              - cartesianPosition (Dict[str, Any]): Robot pose.
     |              - jointAngles (Dict[str, Any]): Joint positions.
     |              - jointTorques (Dict[str, Any]): Joint torque.
     |              - commandedjointAngle (Dict[str, Any]): Last commanded joint angle.
     |              - taskStateTwist (Dict[str, Any]): Task state twist linear.
     |              - loadSideEncValue (Dict[str, Any]): Primary encoder value.
     |              - motorSideEncValue (Dict[str, Any]): Secondary encoder value.
     |              
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              c = r.robot_status('jointAngles')
     |  
     |  rpy_to_quaternion(self, r, p, y)
     |      Convert roll-pitch-yaw (RPY) angles to a quaternion representation.
     |      
     |      Args:
     |          r (float): Roll angle in radians.
     |          p (float): Pitch angle in radians.
     |          y (float): Yaw angle in radians.
     |      
     |      Returns:
     |          list: A list representing the quaternion [w,x, y, z].
     |          
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              rpy = r.rpy_to_quaternion(0,1.1,0)
     |  
     |  save_point(self, point_data)
     |      Stores a point in the database.
     |      
     |      Args:
     |          point_data (dict): A dictionary containing the data for the new point.
     |      
     |      Returns:
     |          bool: True if the point was added successfully
     |      
     |      Raises:
     |          ConnectionError: If a connection to the remote database cannot be established.
     |          ValueError: If point creation failed with the given input data
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  point_data = {
     |                      "type": "Point",
     |                      "visibility": True,
     |                      "description": "Description of your point",
     |                      "originX": 0, # X-Coordinate of your point
     |                      "originY": -0.347247, # Y-Coordinate of your point
     |                      "originZ": 0.139187, # Z-Coordinate of your point
     |                      "originA": 3.1416, # R of your point
     |                      "originB": -0.6458, # P of your point
     |                      "originC": -1.5708, # Y of your point
     |                      "offsetX": 0,
     |                      "offsetY": 0,
     |                      "offsetZ": 0,
     |                      "offsetA": 0,
     |                      "offsetB": 0,
     |                      "offsetC": 0,
     |                      "a1": 1.5708001839725434, # joint 1 of your point
     |                      "a2": 0, # joint 2 of your point
     |                      "a3": -2.49582083, # joint 3 of your point
     |                      "a4": 0, # joint 4 of your point
     |                      "a5": 0, # joint 5 of your point
     |                      "a6": 0, # joint 6 of your point
     |                      "name": "name of your point"
     |                      "__v": 0
     |                  }
     |                  result = r.save_point(point_data)
     |                  print(result)
     |  
     |  servo_j(self, *args, **kwargs)
     |      Method to do Servo in Joint Space
     |      
     |      Args:
     |      - servo_target_position ([int]*dof)     : List of joint target position in rad. Length of list should be equal to degree of freedom
     |      - servo_target_velocity ([int]*dof)     : List of joint target velocity in rad/s. Length of list should be equal to degree of freedom
     |      - servo_target_acceleration ([int]*dof) : List of joint target acceleration in rad/s^2. Length of list should be equal to degree of freedom
     |      
     |      Returns:
     |      - Servo warning and error codes
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              import time
     |              from ruckig import InputParameter, OutputParameter, Result, Ruckig
     |      
     |              r = Robot()
     |      
     |              #Switch to external servo mode
     |              r.activate_servo_interface('position')
     |      
     |              dof = 6
     |      
     |              otg = Ruckig(dof, 0.001)  # DoFs, control cycle
     |              inp = InputParameter(dof)
     |              out = OutputParameter(dof)
     |      
     |              inp.current_position = r.get_current_joint_angles()
     |              inp.current_velocity = [0.]*dof
     |              inp.current_acceleration = [0.]*dof
     |      
     |              inp.target_position = [0., 0., 0., 0., 0., 0.]
     |              inp.target_velocity = [0.]*dof
     |              inp.target_acceleration = [0.]*dof
     |      
     |              inp.max_velocity = [0.5]*dof
     |              inp.max_acceleration = [3]*dof
     |              inp.max_jerk = [10.]*dof
     |              res = Result.Working
     |      
     |      
     |      
     |              while res == Result.Working:
     |                  '''
     |                  Error code is returned through Servo. 
     |                  '''
     |                  error_code = 0
     |                  if(error_code < 3):
     |      
     |                      res = otg.update(inp, out)
     |      
     |                      position = out.new_position
     |                      velocity = out.new_velocity 
     |                      acceleration = out.new_acceleration
     |      
     |                      error_code = r.servo_j(position, velocity, acceleration)
     |                      scaling_factor = r.get_servo_trajectory_scaling_factor()
     |                      out.pass_to_input(inp)
     |                      time.sleep(0.001)
     |                  else:
     |                      print("Servo in error, error code, ", error_code)
     |                      break
     |              r.deactivate_servo_interface()
     |      
     |              r.stop()
     |  
     |  servo_x(self, *args, **kwargs)
     |      Method to do Servo in Cartesian Space
     |      
     |      Args:
     |      - servo_target_position ([int]*7)     : List of cartesian target position in m. Length of list should be equal to 7 (X, Y, Z, qw, qx, qz, qz)
     |      - servo_target_velocity ([int]*7)     : List of cartesian target velocity in m/s. Length of list should be equal to 7
     |      - servo_target_acceleration ([int]*7) : List of cartesian target acceleration in m/s^2. Length of list should be equal 7. Not used in Current Version
     |      - gain parameter (double)             : ServoX gain parameter, used for Propotional controller (should be between [0.2, 100])
     |      
     |      Returns:
     |      - Servo warning and error codes
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              import time
     |              from ruckig import InputParameter, OutputParameter, Result, Ruckig
     |              import copy
     |      
     |              r = Robot()
     |      
     |              #Switch to external servo mode
     |              r.activate_servo_interface('position')
     |      
     |              cart_pose_length = 7 #X,Y,Z,qw,qx,qy,qz
     |      
     |              otg = Ruckig(cart_pose_length, 0.001)  # control cycle
     |              inp = InputParameter(cart_pose_length)
     |              out = OutputParameter(cart_pose_length)
     |      
     |              inp.current_position = r.get_current_cartesian_pose()
     |              inp.current_velocity = [0.]*cart_pose_length
     |              inp.current_acceleration = [0.]*cart_pose_length
     |      
     |              target = copy.deepcopy(inp.current_position)
     |              target[0] += 0.2 # Move 200mm in X direction
     |              inp.target_position = target
     |              inp.target_velocity = [0.]*cart_pose_length
     |              inp.target_acceleration = [0.]*cart_pose_length
     |      
     |              inp.max_velocity = [0.5]*cart_pose_length
     |              inp.max_acceleration = [3]*cart_pose_length
     |              inp.max_jerk = [10.]*cart_pose_length
     |              res = Result.Working
     |      
     |              servox_proportional_gain = 25
     |      
     |              while res == Result.Working:
     |                  '''
     |                  Error code is returned through Servo. 
     |                  '''
     |                  error_code = 0
     |                  if(error_code < 3):
     |      
     |                      res = otg.update(inp, out)
     |      
     |                      position = out.new_position
     |                      velocity = out.new_velocity 
     |                      acceleration = out.new_acceleration
     |      
     |                      error_code = r.servo_x(position, velocity, acceleration, servox_proportional_gain)
     |                      scaling_factor = r.get_servo_trajectory_scaling_factor()
     |                      out.pass_to_input(inp)
     |                      time.sleep(0.001)
     |                  else:
     |                      print("Servo in error, error code, ", error_code)
     |                      break
     |              r.deactivate_servo_interface()
     |      
     |              r.stop()
     |  
     |  set_analog_output(self, io_name, target_value)
     |      Set analog outputs of the control box.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): The name of the analog output.
     |          target_value: The target value to set for the analog output.
     |      
     |      Returns:
     |          bool: The result of the IO operation.
     |      
     |                          
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_set = r.set_analog_output(1,3.2)
     |              print(io_set)
     |  
     |  set_current_position_as_zero(self, list_of_axis, pass_phrase=None)
     |      .. warning::
     |          This function sets the current joint position to zero. Incorrect usage of this function, such as setting incorrect encoder values, may result in serious unexpected behavior of the robot.
     |                 
     |      Sets the current joint position of the given axis to zero.
     |      
     |      Args:
     |          list_of_axis (list): A list of axes that need to be set to zero with values(bool) for each joint.
     |              The length of the list must be equal to the number of joints on the robot.
     |          pass_phrase (string): The password which is required to call this function     
     |      
     |      Returns:
     |          bool: Returns True if the joint position were successfully updated.
     |      
     |      Raises:
     |          ValueError: If the length of the provided encoder offsets list is not equal
     |              to the number of joints on the robot.
     |          ConnectionError: If there is a failure to connect to the robot or the database,
     |              or if there is an issue updating the encoder offsets,
     |              or if the pass_phrase is not correct.
     |              
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.set_current_position_as_zero([False, True, False, True, False, False], pass_phrase = userpassword)
     |  
     |  set_dblout_register(self, first_element, last_element, *values)
     |      Writes values into an element range of the DBLOUT register
     |      
     |              Args:
     |                  first_element (int): index of first integer DBLOUT element to write into.
     |      
     |                  last_element (int): index of last integer DBLOUT element to write into.
     |      
     |                  values (float, ...): target values as arguments
     |      
     |              Returns:
     |                  int: number of elements written, or 0 in case of failure (invalid range, communication failure)
     |      
     |              **Sample Usage:**
     |      
     |                  .. code-block:: python
     |      
     |                      from neurapy.robot import Robot
     |                      r = Robot()
     |                      num_written = r.set_dblout_register(0, 2, 3.3, 6.6, 9.9) # writes three floating point values
     |                                              # into the first three  elements of DBLOUT
     |  
     |  set_digital_output(self, io_name, target_value)
     |      Set digital outputs of the control box.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): The number of the digital output.
     |          target_value: The target value to set for the digital output.
     |      
     |      Raises:
     |      - TypeError: If io_name is not an int value or target_value is not a boolean value
     |      
     |      Returns:
     |          bool: The result of the IO operation.
     |          
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_set = r.set_digital_output(1,True)
     |              print(io_set)
     |  
     |  set_encoder_offsets(self, list_of_encoder_offsets, relative=False, pass_phrase=None)
     |      .. warning::
     |          This function sets the encoder values of joints. Incorrect usage of this function, such as setting incorrect encoder values, may result in serious unexpected behavior of the robot.
     |                 
     |      Sets the encoder offsets for the robot's joints relative or absolute.
     |      
     |      Args:
     |          list_of_encoder_offsets (list): A list of encoder offset values(int) for each joint.
     |              The length of the list must be equal to the number of joints on the robot.
     |          relative (boolean): Defines if the given encoder offset should be added relative to the 
     |              current encoder offsets or set as absolute encoder values.        
     |          pass_phrase (string): The password which is required to call this function     
     |      
     |      Returns:
     |          bool: Returns True if the encoder offsets were successfully updated.
     |      
     |      Raises:
     |          ValueError: If the length of the provided encoder offsets list is not equal
     |              to the number of joints on the robot.
     |          ConnectionError: If there is a failure to connect to the robot or the database,
     |              or if there is an issue updating the encoder offsets,
     |              or if the pass_phrase is not correct.
     |              or if the encoder offset should be applied relative 
     |              
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.set_encoder_offsets([#encoder offsets from the provided robot manual/data sheet], relative = False, pass_phrase = userpassword)
     |  
     |  set_ext_digital_output(self, io_name, target_value)
     |      Set digital outputs of the external IO moduel. Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_name (int): The pin number of the digital output.
     |          target_value: The target value to set for the digital output.
     |      
     |      Raises:
     |      - TypeError: If io_name is not an int value or target_value is not a boolean value
     |      
     |      Returns:
     |          bool: The result of the IO operation.
     |          
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_set = r.set_ext_digital_output(1,True)
     |              print(io_set)
     |  
     |  set_gravity_vector(self, gravity_vector)
     |      .. warning::
     |          This function sets the gravity vector of the robot. Incorrect usage of this function, such as setting incorrect gravity vector, may result in unexpected behavior of the robot.
     |          
     |      To set a new gravity vector values on the robot.
     |      
     |      Args:
     |          List : A list containing the gravity vector values along x,y,z directions
     |          
     |      Raises:
     |          ConnectionError: If there is a failure to connect to the robot's database.
     |          ValueError: If the provided input is not correct(length and magnitude wise)
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |          
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.set_gravity_vector([0,0,9.8])
     |  
     |  set_intout_register(self, first_element, last_element, *values_or_bytes)
     |      Writes values or octets into an element range of the INTOUT register
     |      
     |          Args:
     |              first_element (int): index of first integer INTOUT element to write into.
     |      
     |              last_element (int): index of last integer INTOUT element to write into.
     |      
     |              values_or_bytes (bytes or int, ...): either one python "bytes" argument or target values as arguments
     |      
     |          Returns:
     |              int: number of elements written, or 0 in case of failure (invalid range, communication failure)
     |      
     |          **Sample Usage:**
     |      
     |              .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  num_written = r.set_intout_register(2, 3, b'
     |  
     |  set_joint_acceleration(self, acceleration)
     |      Set the acceleration value for joint motion.
     |      
     |      Parameters:
     |      acceleration (float): The acceleration value for joint motion, ranging from 0 to 100.(Percentage of maximum angular acceleration)
     |      
     |      
     |      Raises:
     |      - TypeError: If acceleration is not a numeric value (int or float).
     |      - ValueError: If acceleration is outside the range of 0 to 100.
     |      
     |      Returns:
     |      None
     |  
     |  set_joint_speed(self, speed)
     |      Set the speed value for joint motion.
     |      
     |      Parameters:
     |      speed (float): The speed value for joint motion, ranging from 0 to 100.(Percentage of maximum angular speed)
     |      
     |      Raises:
     |      - TypeError: If speed is not a numeric value (int or float).
     |      - ValueError: If speed is outside the range of 0 to 100. 
     |      Returns:
     |      None
     |  
     |  set_linear_acceleration(self, acceleration)
     |      Set the acceleration value for linear motion.
     |      
     |      Parameters:
     |      acceleration (float): The acceleration value for linear motion, ranging from 0.0 to 1.0.(m/s2)
     |      
     |      Raises:
     |      - TypeError: If acceleration is not a numeric value (int or float).
     |      - ValueError: If acceleration is outside the range of 0.0 to 1.0.
     |      
     |      Returns:
     |      None
     |  
     |  set_linear_speed(self, speed)
     |      Set the speed value for linear motion.
     |      
     |      Parameters:
     |      speed (float): The speed value for linear motion, ranging from 0.0 to 1.0.(m/s)
     |      
     |      Raises:
     |      - TypeError: If speed is not a numeric value (int or float).
     |      - ValueError: If speed is outside the range of 0.0 to 1.0.
     |      
     |      Returns:
     |      None
     |  
     |  set_load(self, load_mass, load_cog_x, load_cog_y, load_cog_z)
     |      Set a load, e.g. an object which is grasped. The tool parameters (mass, center of gravity) are updated.
     |      
     |      Args:
     |          load_mass (float): mass of load in kg
     |          load_cog_x (float): center of gravity of load with respect to the tcp frame in x direction in meters
     |          load_cog_y (float): center of gravity of load with respect to the tcp frame in y direction in meters
     |          load_cog_z (float): center of gravity of load with respect to the tcp frame in z direction in meters
     |      
     |      Returns:
     |          List: List containing the updated tool properties. i.e . [tool_mass,roll_offset,pitch_offset,yaw_offset,x_offset,y_offset,z_offset,COG_x,COG_y,COG_z,Ixx,Iyy, Izz, Ixy, Ixz, and Iyz]
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.set_load(load_mass=1.1, load_cog_x=0.02, load_cog_y=0.03, load_cog_z=0.04)
     |  
     |  set_mode(self, *args, **kwargs)
     |      .. warning::
     |      
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`switch_to_teach_mode`
     |          - :func:`switch_to_automatic_mode`
     |          - :func:`switch_to_semi_automatic_mode`
     |      
     |      Toggle the robot modes (Teach/Automatic/SemiAutomatic).
     |      
     |      Args:
     |          value (str): The mode to set.
     |              - 'Teach': Change to teach mode.
     |              - 'Automatic': Change to Automatic mode.
     |              - 'SemiAutomatic': Change to semi-automatic mode.
     |      
     |      Returns:
     |          bool: True if the operation is executed successfully, False otherwise.
     |          
     |      Sample Usage:
     |      
     |              .. code-block:: python
     |      
     |                  import time
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.set_mode("Teach")
     |                  time.sleep(1)
     |                  r.set_mode("Automatic")
     |                  time.sleep(1)
     |                  r.set_mode("SemiAutomatic")
     |  
     |  set_opcua_msg(self, *args, **kwargs)
     |      Send a message to the OPC UA server running on the control box.
     |      
     |      Args:
     |          message (str): The message to be sent to the OPC UA server.
     |          opcua_register_index (int): The index of the OPC UA register where the message will be stored.
     |      
     |      Returns:
     |          bool: True if the message is successfully sent and stored in the specified register, False otherwise.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              message = "Hello, OPC UA Server!"
     |              register_index = 1  # Replace with the index of the target OPC UA register
     |              if r.set_opcua_msg(message, register_index):
     |                  print("Message sent and stored in OPC UA register successfully.")
     |              else:
     |                  print("Failed to send the message or store it in the OPC UA register.")
     |  
     |  set_override(self, value)
     |      Set the override value.
     |      
     |      Args:
     |          value (int): The new override value to set.
     |      
     |      Returns:
     |          bool: True if the override value is successfully set, False otherwise.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              new_override_value = 0.5  # it should be from 0 to 1
     |              if r.set_override(new_override_value):
     |                  print(f"Override value set to {new_override_value} successfully.")
     |              else:
     |                  print("Failed to set the override value.")
     |  
     |  set_sim_real(self, *args, **kwargs)
     |      .. warning::
     |      
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`switch_to_real`
     |          - :func:`switch_to_simulation`
     |      
     |          
     |      Method to toggle the sim/real context of the control software
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |          
     |                  import time
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  r.set_sim_real(True)
     |  
     |  set_tool(self, *args, **kwargs)
     |      Notify the gripper/tool change to software components after the physical change.
     |      
     |      Args:
     |          tool_name (str): The name of the tool defined from the GUI.
     |      
     |      Returns:
     |          bool: True if the operation succeeds, False if the operation fails.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.set_tool(tool_name="name given during tool creation in GUI")
     |  
     |  set_tool_digital_output(self, io_number, target_value)
     |      Set the target value on the specified tool digital output.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          io_number(int) : Number of the tool digital output to be triggered
     |          target_value(bool): The target value to set for the tool digital output.
     |      
     |      Returns:
     |          bool: The result of the IO operation.
     |      
     |                              
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_set = r.set_tool_digital_output(1,True) # To set tool digital output 1 to high
     |              print(io_set)
     |  
     |  set_tool_digital_outputs(self, target_value)
     |      Set digital outputs of the tool.Please use get_io_configuration function to get the number of available IOs.
     |      
     |      Args:
     |          target_value(List of floats): The target value to set for the tool digital outputs.
     |      
     |      Returns:
     |          bool: The result of the IO operation.
     |      
     |                              
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_set = r.set_tool_digital_outputs([0.0,1.0,0.0]) # To set tool digital output to high
     |              print(io_set)
     |  
     |  start_external_interface(self, *args, **kwargs)
     |      Starts the external interface.
     |      
     |      Args:
     |          interface_name (str): The name of the interface to start.
     |          *args: Additional arguments to be passed to the interface.
     |          args[0]: supported interface types: ethercat, servo, ethernet_ip, ros, opcua
     |          args[1]: supported interface modes: position, torque (for ros, servo only)
     |          **kwargs: Additional keyword arguments to be passed to the interface.
     |      
     |      Returns:
     |          bool: True if the interface is started successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |        .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  # start the servo interface in position mode
     |                  r.start_external_interface('servo', 'position')
     |  
     |  stop(self, *args, **kwargs)
     |      To stop the robot's motion and to terminate the script execution. This needs to be added at the end of the script(only once) for a proper script termination
     |      
     |      **Sample Usage:**
     |      
     |      .. code-block:: python
     |      
     |          from neurapy.robot import Robot
     |          r = Robot()
     |          r.stop()
     |  
     |  stop_external_interface(self, *args, **kwargs)
     |      Stops the external interface.
     |      
     |      Args:
     |          interface_name (str): The name of the interface to stop.
     |          *args: Additional arguments to be passed to the interface.
     |          args[0]: supported interface types: ethercat, servo, ethernet_ip, ros, opcua
     |          **kwargs: Additional keyword arguments to be passed to the interface.
     |      
     |      Returns:
     |          bool: True if the interface is stopped successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |                  from neurapy.robot import Robot
     |                  r = Robot()
     |                  # stop the servo interface which is currently in activation
     |                  r.stop_external_interface('servo')
     |  
     |  switch_to_automatic_mode(self)
     |      Switch the robot to Automatic mode.
     |      
     |      Returns:
     |          bool: True if the robot successfully switches to Automatic mode, False otherwise.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.switch_to_automatic_mode():
     |                  print("Robot switched to Automatic mode.")
     |              else:
     |                  print("Failed to switch to Automatic mode.")
     |  
     |  switch_to_real(self)
     |      Switches the robot's running context to real mode.
     |      
     |      Returns:
     |          bool: True if the switch was successful, False otherwise.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.switch_to_real()
     |  
     |  switch_to_semi_automatic_mode(self)
     |      Switch the robot to Semi Automatic mode.
     |      
     |      Returns:
     |          bool: True if the robot successfully switches to Semi Automatic mode, False otherwise.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.switch_to_semi_automatic_mode():
     |                  print("Robot switched to Semi Automatic mode.")
     |              else:
     |                  print("Failed to switch to Semi Automatic mode.")
     |  
     |  switch_to_simulation(self)
     |      Switches the robot's running context to simulation mode.
     |      
     |      Returns:
     |          bool: True if the switch was successful, False otherwise.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.switch_to_simulation()
     |  
     |  switch_to_teach_mode(self)
     |      Switch the robot to Teach mode.
     |      
     |      Returns:
     |          bool: True if the robot successfully switches to Teach mode, False otherwise.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              if r.switch_to_teach_mode():
     |                  print("Robot switched to Teach mode.")
     |              else:
     |                  print("Failed to switch to Teach mode.")
     |  
     |  tare_fts(self)
     |      Set the property for taring force toruqe sensor property to true when called and clears the
     |      force torque sensor offsets.
     |      
     |      For lara the tare_fts_ property in rtt_elfin component is set to true and for maira 
     |      tare_fts_ property in the rtt_xenoff component is set to true
     |  
     |  turn_off_free_drive_mode(self)
     |      To turn off free drive mode
     |      Returns:
     |          bool: True if the operation is executed successfully, False otherwise.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.turn_off_free_drive_mode()
     |  
     |  turn_off_jog(self, *args, **kwargs)
     |      Method to disable jogging programatically. This needs to used in conjuction with jog, turn_on_jog methods.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.turn_on_jog(jog_velocity=[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], jog_type='Joint')
     |              r.jog(set_jogging_external_flag=1)
     |              i = 0
     |              while i < 500:
     |                  r.jog(set_jogging_external_flag=1)
     |                  i += 1
     |              r.turn_off_jog()
     |  
     |  turn_on_free_drive_mode(self)
     |      To turn on free drive mode
     |      Returns:
     |          bool: True if the operation is executed successfully, False otherwise.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.turn_on_free_drive_mode()
     |  
     |  turn_on_jog(self, *args, **kwargs)
     |      Method to enable jogging programatically. This needs to used in conjuction with jog, turn_off_jog methods.
     |      
     |      Args:
     |      - jog_velocity (list of float): A list of joint velocities ranging from -1 to 1 for all joints.
     |      - jog_type (str): Specifies the type of jogging, which can be 'Cartesian' or 'Joint'.
     |      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.turn_on_jog(jog_velocity=[0.2, 0.2, 0.2, 0.2, 0.2, 0.2], jog_type='Joint')
     |              r.jog(set_jogging_external_flag=1)
     |              i = 0
     |              while i < 500:
     |                  r.jog(set_jogging_external_flag=1)
     |                  i += 1
     |              r.turn_off_jog()
     |  
     |  unpause(self, *args, **kwargs)
     |      To unpause the robot's motion.
     |      
     |      **Sample Usage:**
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.unpause()
     |  
     |  update_current_tool_parameters(self, *args, **kwargs)
     |      Update the current gripper/tool parameters in the tool list and the selected tool properties.
     |      
     |      Args:
     |          _controlOA;False;True, if the tool is controlled by controlbox analog outputs;Not Requried
     |          _controlOD;False;True, if the tool is controlled by controlbox digital outputs;Not Required
     |          _toolOA;False;True, if the tool is controlled by analog outputs of port present on robot tool flange;Not Required
     |          _toolOD;False;True, if the tool is controlled by digital outputs of port present on robot tool flange;Not Required
     |          autoM;0;Mass of the tool;Required
     |          autoMeasureX;0;tool center of gravity (COG) in X direction,measured from robot's flange frame;Not Required
     |          autoMeasureY;0;tool center of gravity (COG) in Y direction,measured from robot's flange frame;Not Required
     |          autoMeasureZ;0;tool center of gravity (COG) in Z direction,measured from robot's flange frame;Not Required
     |          closeInput;0;percentage of gripper width for close action;Not Required
     |          cmdID;16;Input specific for certain kind of grippers;Not Required
     |          force;0;Gripper closing force; Not Required
     |          gripper;"";Gripper type;Not Required
     |          grippertype;Standard Gripper;Type of gripper Modbus/Standard;Not Required
     |          inertiaXX;0;Ixx of tool;Not Required
     |          inertiaXY;0;Ixy of tool;Not Required
     |          inertiaXZ;0;Ixz of tool;Not Required
     |          inertiaYY;0;Iyy of tool;Not Required
     |          inertiaYZ;0;Iyz of tool;Not Required
     |          inertiaZZ;0;Izz of tool;Not Required
     |          name;N/A;Name of the tool;Required
     |          offCOA;[0, 0, 0, 0, 0, 0, 0, 0];;Not Required
     |          offCOD1;0;if the tool is controlled via control box digital outputs, offCOD1 is the pin mapped to turn off (close) the tool;Not Required
     |          offCOD2;0;;Not Required
     |          offTOA;[0, 0];;Not Required
     |          offTOD;0;if the tool is controlled via tool digital outputs, offTOD is the pin mapped to turn off (close) the tool;Not Required
     |          offsetA;0;TCP roll offset;Not Required
     |          offsetB;0;TCP pitch offset;Not Required
     |          offsetC;0;TCP yaw offset;Not Required
     |          offsetX;0;TCP offset in X;Not Required
     |          offsetY;0;TCP offset in Y;Not Required
     |          offsetZ;0;TCP offset in Z;Not Required
     |          onCOA;[0, 0, 0, 0, 0, 0, 0, 0];;Not Required
     |          onCOD1;0;if the tool is controlled via control box digital outputs, onCOD1 is the pin mapped to turn on (open) the tool;Not Required
     |          onCOD2;0;;Not Required
     |          onTOA;[0, 0];;Not Required
     |          onTOD;0;if the tool is controlled via tool digital outputs, onTOD is the pin mapped to turn on (open) the tool;Not Required
     |          openInput;0;;Not Required
     |          portID;0;;Not Required
     |          protocol;0;;Not Required
     |          robot_type;Tool;;Not Required
     |          slaveID;0;;Not Required
     |          speed;0;;Not Required
     |      
     |      Returns:
     |          bool: True if the operation succeeds, False if the operation fails.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.update_current_tool_parameters(offsetZ=0.1, autoM=0.5)
     |  
     |  update_tool_parameters(self, *args, **kwargs)
     |      Update the gripper/tool parameters in the tool list with a given tool_name.
     |      
     |      Args:
     |          tool_name (str): The name of the tool defined from the GUI.; Required
     |          _controlOA;False;True, if the tool is controlled by controlbox analog outputs;Not Requried
     |          _controlOD;False;True, if the tool is controlled by controlbox digital outputs;Not Required
     |          _toolOA;False;True, if the tool is controlled by analog outputs of port present on robot tool flange;Not Required
     |          _toolOD;False;True, if the tool is controlled by digital outputs of port present on robot tool flange;Not Required
     |          autoM;0;Mass of the tool;Required
     |          autoMeasureX;0;tool center of gravity (COG) in X direction,measured from robot's flange frame;Not Required
     |          autoMeasureY;0;tool center of gravity (COG) in Y direction,measured from robot's flange frame;Not Required
     |          autoMeasureZ;0;tool center of gravity (COG) in Z direction,measured from robot's flange frame;Not Required
     |          closeInput;0;percentage of gripper width for close action;Not Required
     |          cmdID;16;Input specific for certain kind of grippers;Not Required
     |          force;0;Gripper closing force; Not Required
     |          gripper;"";Gripper type;Not Required
     |          grippertype;Standard Gripper;Type of gripper Modbus/Standard;Not Required
     |          inertiaXX;0;Ixx of tool;Not Required
     |          inertiaXY;0;Ixy of tool;Not Required
     |          inertiaXZ;0;Ixz of tool;Not Required
     |          inertiaYY;0;Iyy of tool;Not Required
     |          inertiaYZ;0;Iyz of tool;Not Required
     |          inertiaZZ;0;Izz of tool;Not Required
     |          name;N/A;Name of the tool;Required
     |          offCOA;[0, 0, 0, 0, 0, 0, 0, 0];;Not Required
     |          offCOD1;0;if the tool is controlled via control box digital outputs, offCOD1 is the pin mapped to turn off (close) the tool;Not Required
     |          offCOD2;0;;Not Required
     |          offTOA;[0, 0];;Not Required
     |          offTOD;0;if the tool is controlled via tool digital outputs, offTOD is the pin mapped to turn off (close) the tool;Not Required
     |          offsetA;0;TCP roll offset;Not Required
     |          offsetB;0;TCP pitch offset;Not Required
     |          offsetC;0;TCP yaw offset;Not Required
     |          offsetX;0;TCP offset in X;Not Required
     |          offsetY;0;TCP offset in Y;Not Required
     |          offsetZ;0;TCP offset in Z;Not Required
     |          onCOA;[0, 0, 0, 0, 0, 0, 0, 0];;Not Required
     |          onCOD1;0;if the tool is controlled via control box digital outputs, onCOD1 is the pin mapped to turn on (open) the tool;Not Required
     |          onCOD2;0;;Not Required
     |          onTOA;[0, 0];;Not Required
     |          onTOD;0;if the tool is controlled via tool digital outputs, onTOD is the pin mapped to turn on (open) the tool;Not Required
     |          openInput;0;;Not Required
     |          portID;0;;Not Required
     |          protocol;0;;Not Required
     |          robot_type;Tool;;Not Required
     |          slaveID;0;;Not Required
     |          speed;0;;Not Required
     |      
     |      Returns:
     |          bool: True if the operation succeeds, False if the operation fails.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.update_tool_parameters(tool_name="name given during tool creation in GUI", offsetZ=0.1, autoM=0.5)
     |  
     |  wait(self, *args, **kwargs)
     |      Wait for a specified signal.
     |      
     |      Args:
     |          port_name (str): The name or identifier of the tool-specific analog input.
     |          expected_value (float): The expected value of the analog input.
     |                                            If None, the function waits for any change in the input value
     |      
     |      Returns:
     |          bool: True if the specified condition or event is met, False otherwise.
     |          
     |                                      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait(port_name="DI_2", expected_value=1.0, wait_for_signal=True, wait_time=0.0) #waits till digital input 2 is True
     |              print(io_wait)
     |  
     |  wait_for_analog_input(self, io_name, expected_value, wait_time=0.0)
     |      Wait for an analog input signal to match the expected value.
     |      
     |      Args:
     |          io_name (str): The name or identifier of the analog input.
     |          expected_value (float): The expected value of the analog input.
     |          wait_time(float): waits for this amount of time(in secs), before returning. default value is 0
     |      
     |      Returns:
     |          bool: True if the analog input matches the expected value, False otherwise.
     |      
     |                                      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_analog_input(1,2.3) #waits till analog input 1 is 2.3
     |              print(io_wait)
     |  
     |  wait_for_digital_input(self, io_name, expected_value, wait_time=0.0)
     |      Wait for a digital input signal to match the expected value.
     |      
     |      Args:
     |          io_name (str): The name or identifier of the digital input.
     |          expected_value (bool): The expected value of the digital input
     |          wait_time(float): waits for this amount of time(in secs), before returning. default value is 0
     |      
     |      Returns:
     |          bool: True if the digital input matches the expected value, False otherwise.
     |          
     |                                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_digital_input(1,True) #waits till digital input 1 is True
     |              print(io_wait)
     |  
     |  wait_for_digital_input_timer_off_delay(self, io_name, delay=0.0)
     |      Wait for a given delay and returns after the given digital input signal reaches low .
     |      
     |      Args:
     |          io_name (str): The name or identifier of the digital input.
     |          wait_time(float): waits for this amount of time(in secs), before returning. default value is 0
     |                                 
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_digital_input_timer_off_delay(1,10) #waits for 10sec and returns after digital input 1 reaches low
     |              print(io_wait)
     |  
     |  wait_for_digital_input_timer_on_delay(self, io_name, delay=0.0)
     |      Wait for a given delay and returns after the given digital input signal reaches high .
     |      
     |      Args:
     |          io_name (str): The name or identifier of the digital input.
     |          wait_time(float): waits for this amount of time(in secs), before returning. default value is 0
     |      
     |      Returns:
     |          bool: True if the digital input matches the expected value, False otherwise.
     |          
     |                                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_digital_input_timer_on_delay(1,10) #waits for 10sec and returns after digital input 1 reaches high
     |              print(io_wait)
     |  
     |  wait_for_tool_analog_input(self, io_name, expected_value)
     |      Wait for a tool-specific analog input signal to match the expected value.
     |      
     |      Args:
     |          io_name (str): The name or identifier of the tool-specific analog input.
     |          expected_value (float): The expected value of the analog input.
     |                                            If None, the function waits for any change in the input value.
     |      
     |      Returns:
     |          bool: True if the tool-specific analog input matches the expected value, False otherwise.
     |      
     |                                      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_tool_analog_input(1,2.3v) #waits till tool analog input 1 is 2.3v
     |              print(io_wait)
     |  
     |  wait_for_tool_digital_input(self, io_name, expected_value, wait_time=0.0)
     |      Wait for a tool-specific digital input signal to match the expected value.
     |      
     |      Args:
     |          io_name (str): The name or identifier of the tool-specific digital input.
     |          expected_value (bool): The expected value of the digital input.
     |          wait_time(float): waits for this amount of time(in secs), before returning. default value is 0
     |      
     |      Returns:
     |          bool: True if the tool-specific digital input matches the expected value, False otherwise.
     |          
     |                                      
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_tool_digital_input(1,True) #waits till tool digital input 1 is True
     |              print(io_wait)
     |  
     |  wait_for_tool_digital_input_timer_off_delay(self, io_name, delay=0.0)
     |      Wait for a given delay and returns after the given tool digital input signal reaches low .
     |      
     |      Args:
     |          io_name (str): The name or identifier of the tool digital input.
     |          wait_time(float): waits for this amount of time(in secs), before returning. default value is 0
     |                                 
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_tool_digital_input_timer_off_delay(1,10) #waits for 10sec and returns after tool digital input 1 reaches low
     |              print(io_wait)
     |  
     |  wait_for_tool_digital_input_timer_on_delay(self, io_name, delay=0.0)
     |      Wait for a given delay and returns after the given tool digital input signal reaches high .
     |      
     |      Args:
     |          io_name (str): The name or identifier of the tool digital input.
     |          wait_time(float): waits for this amount of time(in secs), before returning. default value is 0
     |      
     |      Returns:
     |          bool: True if the digital input matches the expected value, False otherwise.
     |          
     |                                  
     |      **Sample Usage**
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              io_wait = r.wait_for_tool_digital_input_timer_on_delay(1,10) #waits for 10sec and returns after tool digital input 1 reaches high
     |              print(io_wait)
     |  
     |  zero_g(self, *args, **kwargs)
     |      .. warning::
     |      
     |          This function is deprecated and will be removed in the next version. Please use the following functions instead:
     |      
     |          - :func:`turn_on_free_drive_mode`
     |          - :func:`turn_off_free_drive_mode`
     |      
     |          
     |      Toggle the freedrive/Gravity compensation mode.
     |      
     |      Args:
     |          value (str): Specifies the mode action.
     |              - 'on'  : Turn on the freedrive mode.
     |              - 'off' : Turn off the freedrive mode.
     |      
     |      Returns:
     |          bool: True if the operation is executed successfully, False otherwise.
     |      
     |      Sample Usage:
     |      
     |          .. code-block:: python
     |      
     |              import time
     |              from neurapy.robot import Robot
     |              r = Robot()
     |              r.zero_g("on")
     |              time.sleep(1)
     |              r.zero_g("off")
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)

DATA
    VERBOSE = False
    __test__ = {}

FILE
    /usr/lib/python3/dist-packages/neurapy/robot.cpython-36m-x86_64-linux-gnu.so


